import {
  DataBindMapper,
  Paired_default,
  index,
  index2,
  index3,
  max,
  min,
  octree,
  ordinal,
  require_prop_types,
  threeRenderObjects,
  tinycolor
} from "./chunk-JGQT6655.js";
import {
  AmbientLight,
  Box3,
  BufferAttribute,
  BufferGeometry,
  Color,
  ConeGeometry,
  Controls,
  CubicBezierCurve3,
  CylinderGeometry,
  DirectionalLight,
  Group,
  Line,
  LineBasicMaterial,
  MOUSE,
  Matrix4,
  Mesh,
  MeshLambertMaterial,
  Plane,
  QuadraticBezierCurve3,
  REVISION,
  Raycaster,
  SphereGeometry,
  TOUCH,
  TubeGeometry,
  Vector2,
  Vector3
} from "./chunk-IYG2VWV5.js";
import {
  dispatch_default,
  timer
} from "./chunk-A3W4J62T.js";
import "./chunk-H3EPA7TM.js";
import "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js
var require_getVariableName = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/getVariableName.js"(exports, module) {
    module.exports = function getVariableName(index5) {
      if (index5 === 0) return "x";
      if (index5 === 1) return "y";
      if (index5 === 2) return "z";
      return "c" + (index5 + 1);
    };
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js
var require_createPatternBuilder = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/createPatternBuilder.js"(exports, module) {
    var getVariableName = require_getVariableName();
    module.exports = function createPatternBuilder(dimension) {
      return pattern;
      function pattern(template, config) {
        let indent = config && config.indent || 0;
        let join = config && config.join !== void 0 ? config.join : "\n";
        let indentString = Array(indent + 1).join(" ");
        let buffer = [];
        for (let i = 0; i < dimension; ++i) {
          let variableName = getVariableName(i);
          let prefix = i === 0 ? "" : indentString;
          buffer.push(prefix + template.replace(/{var}/g, variableName));
        }
        return buffer.join(join);
      }
    };
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js
var require_generateCreateBody = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateBody.js"(exports, module) {
    var createPatternBuilder = require_createPatternBuilder();
    module.exports = generateCreateBodyFunction;
    module.exports.generateCreateBodyFunctionBody = generateCreateBodyFunctionBody;
    module.exports.getVectorCode = getVectorCode;
    module.exports.getBodyCode = getBodyCode;
    function generateCreateBodyFunction(dimension, debugSetters) {
      let code = generateCreateBodyFunctionBody(dimension, debugSetters);
      let { Body } = new Function(code)();
      return Body;
    }
    function generateCreateBodyFunctionBody(dimension, debugSetters) {
      let code = `
${getVectorCode(dimension, debugSetters)}
${getBodyCode(dimension, debugSetters)}
return {Body: Body, Vector: Vector};
`;
      return code;
    }
    function getBodyCode(dimension) {
      let pattern = createPatternBuilder(dimension);
      let variableList = pattern("{var}", { join: ", " });
      return `
function Body(${variableList}) {
  this.isPinned = false;
  this.pos = new Vector(${variableList});
  this.force = new Vector();
  this.velocity = new Vector();
  this.mass = 1;

  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.reset = function() {
  this.force.reset();
  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.setPosition = function (${variableList}) {
  ${pattern("this.pos.{var} = {var} || 0;", { indent: 2 })}
};`;
    }
    function getVectorCode(dimension, debugSetters) {
      let pattern = createPatternBuilder(dimension);
      let setters = "";
      if (debugSetters) {
        setters = `${pattern("\n   var v{var};\nObject.defineProperty(this, '{var}', {\n  set: function(v) { \n    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');\n    v{var} = v; \n  },\n  get: function() { return v{var}; }\n});")}`;
      }
      let variableList = pattern("{var}", { join: ", " });
      return `function Vector(${variableList}) {
  ${setters}
    if (typeof arguments[0] === 'object') {
      // could be another vector
      let v = arguments[0];
      ${pattern('if (!Number.isFinite(v.{var})) throw new Error("Expected value is not a finite number at Vector constructor ({var})");', { indent: 4 })}
      ${pattern("this.{var} = v.{var};", { indent: 4 })}
    } else {
      ${pattern('this.{var} = typeof {var} === "number" ? {var} : 0;', { indent: 4 })}
    }
  }
  
  Vector.prototype.reset = function () {
    ${pattern("this.{var} = ", { join: "" })}0;
  };`;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js
var require_generateQuadTree = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateQuadTree.js"(exports, module) {
    var createPatternBuilder = require_createPatternBuilder();
    var getVariableName = require_getVariableName();
    module.exports = generateQuadTreeFunction;
    module.exports.generateQuadTreeFunctionBody = generateQuadTreeFunctionBody;
    module.exports.getInsertStackCode = getInsertStackCode;
    module.exports.getQuadNodeCode = getQuadNodeCode;
    module.exports.isSamePosition = isSamePosition;
    module.exports.getChildBodyCode = getChildBodyCode;
    module.exports.setChildBodyCode = setChildBodyCode;
    function generateQuadTreeFunction(dimension) {
      let code = generateQuadTreeFunctionBody(dimension);
      return new Function(code)();
    }
    function generateQuadTreeFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let quadCount = Math.pow(2, dimension);
      let code = `
${getInsertStackCode()}
${getQuadNodeCode(dimension)}
${isSamePosition(dimension)}
${getChildBodyCode(dimension)}
${setChildBodyCode(dimension)}

function createQuadTree(options, random) {
  options = options || {};
  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

  var gravity = options.gravity;
  var updateQueue = [];
  var insertStack = new InsertStack();
  var theta = options.theta;

  var nodesCache = [];
  var currentInCache = 0;
  var root = newNode();

  return {
    insertBodies: insertBodies,

    /**
     * Gets root node if it is present
     */
    getRoot: function() {
      return root;
    },

    updateBodyForce: update,

    options: function(newOptions) {
      if (newOptions) {
        if (typeof newOptions.gravity === 'number') {
          gravity = newOptions.gravity;
        }
        if (typeof newOptions.theta === 'number') {
          theta = newOptions.theta;
        }

        return this;
      }

      return {
        gravity: gravity,
        theta: theta
      };
    }
  };

  function newNode() {
    // To avoid pressure on GC we reuse nodes.
    var node = nodesCache[currentInCache];
    if (node) {
${assignQuads("      node.")}
      node.body = null;
      node.mass = ${pattern("node.mass_{var} = ", { join: "" })}0;
      ${pattern("node.min_{var} = node.max_{var} = ", { join: "" })}0;
    } else {
      node = new QuadNode();
      nodesCache[currentInCache] = node;
    }

    ++currentInCache;
    return node;
  }

  function update(sourceBody) {
    var queue = updateQueue;
    var v;
    ${pattern("var d{var};", { indent: 4 })}
    var r; 
    ${pattern("var f{var} = 0;", { indent: 4 })}
    var queueLength = 1;
    var shiftIdx = 0;
    var pushIdx = 1;

    queue[0] = root;

    while (queueLength) {
      var node = queue[shiftIdx];
      var body = node.body;

      queueLength -= 1;
      shiftIdx += 1;
      var differentBody = (body !== sourceBody);
      if (body && differentBody) {
        // If the current node is a leaf node (and it is not source body),
        // calculate the force exerted by the current node on body, and add this
        // amount to body's net force.
        ${pattern("d{var} = body.pos.{var} - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Poor man's protection against zero distance.
          ${pattern("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});
        }

        // This is standard gravitation force calculation but we divide
        // by r^3 to save two operations when normalizing force vector.
        v = gravity * body.mass * sourceBody.mass / (r * r * r);
        ${pattern("f{var} += v * d{var};", { indent: 8 })}
      } else if (differentBody) {
        // Otherwise, calculate the ratio s / r,  where s is the width of the region
        // represented by the internal node, and r is the distance between the body
        // and the node's center-of-mass
        ${pattern("d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Sorry about code duplication. I don't want to create many functions
          // right away. Just want to see performance first.
          ${pattern("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});
        }
        // If s / r < Î¸, treat this internal node as a single body, and calculate the
        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
        if ((node.max_${getVariableName(0)} - node.min_${getVariableName(0)}) / r < theta) {
          // in the if statement above we consider node's width only
          // because the region was made into square during tree creation.
          // Thus there is no difference between using width or height.
          v = gravity * node.mass * sourceBody.mass / (r * r * r);
          ${pattern("f{var} += v * d{var};", { indent: 10 })}
        } else {
          // Otherwise, run the procedure recursively on each of the current node's children.

          // I intentionally unfolded this loop, to save several CPU cycles.
${runRecursiveOnChildren()}
        }
      }
    }

    ${pattern("sourceBody.force.{var} += f{var};", { indent: 4 })}
  }

  function insertBodies(bodies) {
    ${pattern("var {var}min = Number.MAX_VALUE;", { indent: 4 })}
    ${pattern("var {var}max = Number.MIN_VALUE;", { indent: 4 })}
    var i = bodies.length;

    // To reduce quad tree depth we are looking for exact bounding box of all particles.
    while (i--) {
      var pos = bodies[i].pos;
      ${pattern("if (pos.{var} < {var}min) {var}min = pos.{var};", { indent: 6 })}
      ${pattern("if (pos.{var} > {var}max) {var}max = pos.{var};", { indent: 6 })}
    }

    // Makes the bounds square.
    var maxSideLength = -Infinity;
    ${pattern("if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;", { indent: 4 })}

    currentInCache = 0;
    root = newNode();
    ${pattern("root.min_{var} = {var}min;", { indent: 4 })}
    ${pattern("root.max_{var} = {var}min + maxSideLength;", { indent: 4 })}

    i = bodies.length - 1;
    if (i >= 0) {
      root.body = bodies[i];
    }
    while (i--) {
      insert(bodies[i], root);
    }
  }

  function insert(newBody) {
    insertStack.reset();
    insertStack.push(root, newBody);

    while (!insertStack.isEmpty()) {
      var stackItem = insertStack.pop();
      var node = stackItem.node;
      var body = stackItem.body;

      if (!node.body) {
        // This is internal node. Update the total mass of the node and center-of-mass.
        ${pattern("var {var} = body.pos.{var};", { indent: 8 })}
        node.mass += body.mass;
        ${pattern("node.mass_{var} += body.mass * {var};", { indent: 8 })}

        // Recursively insert the body in the appropriate quadrant.
        // But first find the appropriate quadrant.
        var quadIdx = 0; // Assume we are in the 0's quad.
        ${pattern("var min_{var} = node.min_{var};", { indent: 8 })}
        ${pattern("var max_{var} = (min_{var} + node.max_{var}) / 2;", { indent: 8 })}

${assignInsertionQuadIndex(8)}

        var child = getChild(node, quadIdx);

        if (!child) {
          // The node is internal but this quadrant is not taken. Add
          // subnode to it.
          child = newNode();
          ${pattern("child.min_{var} = min_{var};", { indent: 10 })}
          ${pattern("child.max_{var} = max_{var};", { indent: 10 })}
          child.body = body;

          setChild(node, quadIdx, child);
        } else {
          // continue searching in this quadrant.
          insertStack.push(child, body);
        }
      } else {
        // We are trying to add to the leaf node.
        // We have to convert current leaf into internal node
        // and continue adding two nodes.
        var oldBody = node.body;
        node.body = null; // internal nodes do not cary bodies

        if (isSamePosition(oldBody.pos, body.pos)) {
          // Prevent infinite subdivision by bumping one node
          // anywhere in this quadrant
          var retriesCount = 3;
          do {
            var offset = random.nextDouble();
            ${pattern("var d{var} = (node.max_{var} - node.min_{var}) * offset;", { indent: 12 })}

            ${pattern("oldBody.pos.{var} = node.min_{var} + d{var};", { indent: 12 })}
            retriesCount -= 1;
            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
            // This is very bad, we ran out of precision.
            // if we do not return from the method we'll get into
            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
            // Next layout iteration should get larger bounding box in the first step and fix this
            return;
          }
        }
        // Next iteration should subdivide node further.
        insertStack.push(node, oldBody);
        insertStack.push(node, body);
      }
    }
  }
}
return createQuadTree;

`;
      return code;
      function assignInsertionQuadIndex(indentCount) {
        let insertionCode = [];
        let indent = Array(indentCount + 1).join(" ");
        for (let i = 0; i < dimension; ++i) {
          insertionCode.push(indent + `if (${getVariableName(i)} > max_${getVariableName(i)}) {`);
          insertionCode.push(indent + `  quadIdx = quadIdx + ${Math.pow(2, i)};`);
          insertionCode.push(indent + `  min_${getVariableName(i)} = max_${getVariableName(i)};`);
          insertionCode.push(indent + `  max_${getVariableName(i)} = node.max_${getVariableName(i)};`);
          insertionCode.push(indent + `}`);
        }
        return insertionCode.join("\n");
      }
      function runRecursiveOnChildren() {
        let indent = Array(11).join(" ");
        let recursiveCode = [];
        for (let i = 0; i < quadCount; ++i) {
          recursiveCode.push(indent + `if (node.quad${i}) {`);
          recursiveCode.push(indent + `  queue[pushIdx] = node.quad${i};`);
          recursiveCode.push(indent + `  queueLength += 1;`);
          recursiveCode.push(indent + `  pushIdx += 1;`);
          recursiveCode.push(indent + `}`);
        }
        return recursiveCode.join("\n");
      }
      function assignQuads(indent) {
        let quads = [];
        for (let i = 0; i < quadCount; ++i) {
          quads.push(`${indent}quad${i} = null;`);
        }
        return quads.join("\n");
      }
    }
    function isSamePosition(dimension) {
      let pattern = createPatternBuilder(dimension);
      return `
  function isSamePosition(point1, point2) {
    ${pattern("var d{var} = Math.abs(point1.{var} - point2.{var});", { indent: 2 })}
  
    return ${pattern("d{var} < 1e-8", { join: " && " })};
  }  
`;
    }
    function setChildBodyCode(dimension) {
      var quadCount = Math.pow(2, dimension);
      return `
function setChild(node, idx, child) {
  ${setChildBody()}
}`;
      function setChildBody() {
        let childBody = [];
        for (let i = 0; i < quadCount; ++i) {
          let prefix = i === 0 ? "  " : "  else ";
          childBody.push(`${prefix}if (idx === ${i}) node.quad${i} = child;`);
        }
        return childBody.join("\n");
      }
    }
    function getChildBodyCode(dimension) {
      return `function getChild(node, idx) {
${getChildBody()}
  return null;
}`;
      function getChildBody() {
        let childBody = [];
        let quadCount = Math.pow(2, dimension);
        for (let i = 0; i < quadCount; ++i) {
          childBody.push(`  if (idx === ${i}) return node.quad${i};`);
        }
        return childBody.join("\n");
      }
    }
    function getQuadNodeCode(dimension) {
      let pattern = createPatternBuilder(dimension);
      let quadCount = Math.pow(2, dimension);
      var quadNodeCode = `
function QuadNode() {
  // body stored inside this node. In quad tree only leaf nodes (by construction)
  // contain bodies:
  this.body = null;

  // Child nodes are stored in quads. Each quad is presented by number:
  // 0 | 1
  // -----
  // 2 | 3
${assignQuads("  this.")}

  // Total mass of current node
  this.mass = 0;

  // Center of mass coordinates
  ${pattern("this.mass_{var} = 0;", { indent: 2 })}

  // bounding box coordinates
  ${pattern("this.min_{var} = 0;", { indent: 2 })}
  ${pattern("this.max_{var} = 0;", { indent: 2 })}
}
`;
      return quadNodeCode;
      function assignQuads(indent) {
        let quads = [];
        for (let i = 0; i < quadCount; ++i) {
          quads.push(`${indent}quad${i} = null;`);
        }
        return quads.join("\n");
      }
    }
    function getInsertStackCode() {
      return `
/**
 * Our implementation of QuadTree is non-recursive to avoid GC hit
 * This data structure represent stack of elements
 * which we are trying to insert into quad tree.
 */
function InsertStack () {
    this.stack = [];
    this.popIdx = 0;
}

InsertStack.prototype = {
    isEmpty: function() {
        return this.popIdx === 0;
    },
    push: function (node, body) {
        var item = this.stack[this.popIdx];
        if (!item) {
            // we are trying to avoid memory pressure: create new element
            // only when absolutely necessary
            this.stack[this.popIdx] = new InsertStackElement(node, body);
        } else {
            item.node = node;
            item.body = body;
        }
        ++this.popIdx;
    },
    pop: function () {
        if (this.popIdx > 0) {
            return this.stack[--this.popIdx];
        }
    },
    reset: function () {
        this.popIdx = 0;
    }
};

function InsertStackElement(node, body) {
    this.node = node; // QuadTree node
    this.body = body; // physical body which needs to be inserted to node
}
`;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js
var require_generateBounds = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js"(exports, module) {
    module.exports = generateBoundsFunction;
    module.exports.generateFunctionBody = generateBoundsFunctionBody;
    var createPatternBuilder = require_createPatternBuilder();
    function generateBoundsFunction(dimension) {
      let code = generateBoundsFunctionBody(dimension);
      return new Function("bodies", "settings", "random", code);
    }
    function generateBoundsFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code = `
  var boundingBox = {
    ${pattern("min_{var}: 0, max_{var}: 0,", { indent: 4 })}
  };

  return {
    box: boundingBox,

    update: updateBoundingBox,

    reset: resetBoundingBox,

    getBestNewPosition: function (neighbors) {
      var ${pattern("base_{var} = 0", { join: ", " })};

      if (neighbors.length) {
        for (var i = 0; i < neighbors.length; ++i) {
          let neighborPos = neighbors[i].pos;
          ${pattern("base_{var} += neighborPos.{var};", { indent: 10 })}
        }

        ${pattern("base_{var} /= neighbors.length;", { indent: 8 })}
      } else {
        ${pattern("base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;", { indent: 8 })}
      }

      var springLength = settings.springLength;
      return {
        ${pattern("{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,", { indent: 8 })}
      };
    }
  };

  function updateBoundingBox() {
    var i = bodies.length;
    if (i === 0) return; // No bodies - no borders.

    ${pattern("var max_{var} = -Infinity;", { indent: 4 })}
    ${pattern("var min_{var} = Infinity;", { indent: 4 })}

    while(i--) {
      // this is O(n), it could be done faster with quadtree, if we check the root node bounds
      var bodyPos = bodies[i].pos;
      ${pattern("if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};", { indent: 6 })}
      ${pattern("if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};", { indent: 6 })}
    }

    ${pattern("boundingBox.min_{var} = min_{var};", { indent: 4 })}
    ${pattern("boundingBox.max_{var} = max_{var};", { indent: 4 })}
  }

  function resetBoundingBox() {
    ${pattern("boundingBox.min_{var} = boundingBox.max_{var} = 0;", { indent: 4 })}
  }
`;
      return code;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js
var require_generateCreateDragForce = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateDragForce.js"(exports, module) {
    var createPatternBuilder = require_createPatternBuilder();
    module.exports = generateCreateDragForceFunction;
    module.exports.generateCreateDragForceFunctionBody = generateCreateDragForceFunctionBody;
    function generateCreateDragForceFunction(dimension) {
      let code = generateCreateDragForceFunctionBody(dimension);
      return new Function("options", code);
    }
    function generateCreateDragForceFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code = `
  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');

  return {
    update: function(body) {
      ${pattern("body.force.{var} -= options.dragCoefficient * body.velocity.{var};", { indent: 6 })}
    }
  };
`;
      return code;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js
var require_generateCreateSpringForce = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateCreateSpringForce.js"(exports, module) {
    var createPatternBuilder = require_createPatternBuilder();
    module.exports = generateCreateSpringForceFunction;
    module.exports.generateCreateSpringForceFunctionBody = generateCreateSpringForceFunctionBody;
    function generateCreateSpringForceFunction(dimension) {
      let code = generateCreateSpringForceFunctionBody(dimension);
      return new Function("options", "random", code);
    }
    function generateCreateSpringForceFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code = `
  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');
  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');

  return {
    /**
     * Updates forces acting on a spring
     */
    update: function (spring) {
      var body1 = spring.from;
      var body2 = spring.to;
      var length = spring.length < 0 ? options.springLength : spring.length;
      ${pattern("var d{var} = body2.pos.{var} - body1.pos.{var};", { indent: 6 })}
      var r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});

      if (r === 0) {
        ${pattern("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 8 })}
        r = Math.sqrt(${pattern("d{var} * d{var}", { join: " + " })});
      }

      var d = r - length;
      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;

      ${pattern("body1.force.{var} += coefficient * d{var}", { indent: 6 })};
      body1.springCount += 1;
      body1.springLength += r;

      ${pattern("body2.force.{var} -= coefficient * d{var}", { indent: 6 })};
      body2.springCount += 1;
      body2.springLength += r;
    }
  };
`;
      return code;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js
var require_generateIntegrator = __commonJS({
  "node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js"(exports, module) {
    var createPatternBuilder = require_createPatternBuilder();
    module.exports = generateIntegratorFunction;
    module.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;
    function generateIntegratorFunction(dimension) {
      let code = generateIntegratorFunctionBody(dimension);
      return new Function("bodies", "timeStep", "adaptiveTimeStepWeight", code);
    }
    function generateIntegratorFunctionBody(dimension) {
      let pattern = createPatternBuilder(dimension);
      let code = `
  var length = bodies.length;
  if (length === 0) return 0;

  ${pattern("var d{var} = 0, t{var} = 0;", { indent: 2 })}

  for (var i = 0; i < length; ++i) {
    var body = bodies[i];
    if (body.isPinned) continue;

    if (adaptiveTimeStepWeight && body.springCount) {
      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);
    }

    var coeff = timeStep / body.mass;

    ${pattern("body.velocity.{var} += coeff * body.force.{var};", { indent: 4 })}
    ${pattern("var v{var} = body.velocity.{var};", { indent: 4 })}
    var v = Math.sqrt(${pattern("v{var} * v{var}", { join: " + " })});

    if (v > 1) {
      // We normalize it so that we move within timeStep range. 
      // for the case when v <= 1 - we let velocity to fade out.
      ${pattern("body.velocity.{var} = v{var} / v;", { indent: 6 })}
    }

    ${pattern("d{var} = timeStep * body.velocity.{var};", { indent: 4 })}

    ${pattern("body.pos.{var} += d{var};", { indent: 4 })}

    ${pattern("t{var} += Math.abs(d{var});", { indent: 4 })}
  }

  return (${pattern("t{var} * t{var}", { join: " + " })})/length;
`;
      return code;
    }
  }
});

// node_modules/ngraph.forcelayout/lib/spring.js
var require_spring = __commonJS({
  "node_modules/ngraph.forcelayout/lib/spring.js"(exports, module) {
    module.exports = Spring;
    function Spring(fromBody, toBody, length, springCoefficient) {
      this.from = fromBody;
      this.to = toBody;
      this.length = length;
      this.coefficient = springCoefficient;
    }
  }
});

// node_modules/ngraph.merge/index.js
var require_ngraph = __commonJS({
  "node_modules/ngraph.merge/index.js"(exports, module) {
    module.exports = merge;
    function merge(target, options) {
      var key;
      if (!target) {
        target = {};
      }
      if (options) {
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            var targetHasIt = target.hasOwnProperty(key), optionsValueType = typeof options[key], shouldReplace = !targetHasIt || typeof target[key] !== optionsValueType;
            if (shouldReplace) {
              target[key] = options[key];
            } else if (optionsValueType === "object") {
              target[key] = merge(target[key], options[key]);
            }
          }
        }
      }
      return target;
    }
  }
});

// node_modules/ngraph.events/dist/ngraph.events.cjs
var require_ngraph_events = __commonJS({
  "node_modules/ngraph.events/dist/ngraph.events.cjs"(exports, module) {
    "use strict";
    function c2(e) {
      s(e);
      const t = a2(e);
      return e.on = t.on, e.off = t.off, e.fire = t.fire, e;
    }
    function a2(e) {
      let t = /* @__PURE__ */ Object.create(null);
      return { on: function(n, r, f) {
        if (typeof r != "function") throw new Error("callback is expected to be a function");
        let o = t[n];
        return o || (o = t[n] = []), o.push({ callback: r, ctx: f }), e;
      }, off: function(n, r) {
        if (typeof n > "u") return t = /* @__PURE__ */ Object.create(null), e;
        if (t[n]) if (typeof r != "function") delete t[n];
        else {
          const l = t[n];
          for (let i = 0; i < l.length; ++i) l[i].callback === r && l.splice(i, 1);
        }
        return e;
      }, fire: function(n) {
        const r = t[n];
        if (!r) return e;
        let f;
        arguments.length > 1 && (f = Array.prototype.slice.call(arguments, 1));
        for (let o = 0; o < r.length; ++o) {
          const l = r[o];
          l.callback.apply(l.ctx, f);
        }
        return e;
      } };
    }
    function s(e) {
      if (!e) throw new Error("Eventify cannot use falsy object as events subject");
      const t = ["on", "fire", "off"];
      for (let n = 0; n < t.length; ++n) if (e.hasOwnProperty(t[n])) throw new Error("Subject cannot be eventified, since it already has property '" + t[n] + "'");
    }
    module.exports = c2;
  }
});

// node_modules/ngraph.random/index.js
var require_ngraph2 = __commonJS({
  "node_modules/ngraph.random/index.js"(exports, module) {
    module.exports = random;
    module.exports.random = random, module.exports.randomIterator = randomIterator;
    function random(inputSeed) {
      var seed = typeof inputSeed === "number" ? inputSeed : +/* @__PURE__ */ new Date();
      return new Generator(seed);
    }
    function Generator(seed) {
      this.seed = seed;
    }
    Generator.prototype.next = next;
    Generator.prototype.nextDouble = nextDouble;
    Generator.prototype.uniform = nextDouble;
    Generator.prototype.gaussian = gaussian;
    Generator.prototype.random = nextDouble;
    function gaussian() {
      var r, x2, y2;
      do {
        x2 = this.nextDouble() * 2 - 1;
        y2 = this.nextDouble() * 2 - 1;
        r = x2 * x2 + y2 * y2;
      } while (r >= 1 || r === 0);
      return x2 * Math.sqrt(-2 * Math.log(r) / r);
    }
    Generator.prototype.levy = levy;
    function levy() {
      var beta = 3 / 2;
      var sigma = Math.pow(
        gamma(1 + beta) * Math.sin(Math.PI * beta / 2) / (gamma((1 + beta) / 2) * beta * Math.pow(2, (beta - 1) / 2)),
        1 / beta
      );
      return this.gaussian() * sigma / Math.pow(Math.abs(this.gaussian()), 1 / beta);
    }
    function gamma(z2) {
      return Math.sqrt(2 * Math.PI / z2) * Math.pow(1 / Math.E * (z2 + 1 / (12 * z2 - 1 / (10 * z2))), z2);
    }
    function nextDouble() {
      var seed = this.seed;
      seed = seed + 2127912214 + (seed << 12) & 4294967295;
      seed = (seed ^ 3345072700 ^ seed >>> 19) & 4294967295;
      seed = seed + 374761393 + (seed << 5) & 4294967295;
      seed = (seed + 3550635116 ^ seed << 9) & 4294967295;
      seed = seed + 4251993797 + (seed << 3) & 4294967295;
      seed = (seed ^ 3042594569 ^ seed >>> 16) & 4294967295;
      this.seed = seed;
      return (seed & 268435455) / 268435456;
    }
    function next(maxValue) {
      return Math.floor(this.nextDouble() * maxValue);
    }
    function randomIterator(array, customRandom) {
      var localRandom = customRandom || random();
      if (typeof localRandom.next !== "function") {
        throw new Error("customRandom does not match expected API: next() function is missing");
      }
      return {
        /**
         * Visits every single element of a collection once, in a random order.
         * Note: collection is modified in place.
         */
        forEach,
        /**
         * Shuffles array randomly, in place.
         */
        shuffle
      };
      function shuffle() {
        var i, j, t;
        for (i = array.length - 1; i > 0; --i) {
          j = localRandom.next(i + 1);
          t = array[j];
          array[j] = array[i];
          array[i] = t;
        }
        return array;
      }
      function forEach(callback) {
        var i, j, t;
        for (i = array.length - 1; i > 0; --i) {
          j = localRandom.next(i + 1);
          t = array[j];
          array[j] = array[i];
          array[i] = t;
          callback(t);
        }
        if (array.length) {
          callback(array[0]);
        }
      }
    }
  }
});

// node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js
var require_createPhysicsSimulator = __commonJS({
  "node_modules/ngraph.forcelayout/lib/createPhysicsSimulator.js"(exports, module) {
    module.exports = createPhysicsSimulator;
    var generateCreateBodyFunction = require_generateCreateBody();
    var generateQuadTreeFunction = require_generateQuadTree();
    var generateBoundsFunction = require_generateBounds();
    var generateCreateDragForceFunction = require_generateCreateDragForce();
    var generateCreateSpringForceFunction = require_generateCreateSpringForce();
    var generateIntegratorFunction = require_generateIntegrator();
    var dimensionalCache = {};
    function createPhysicsSimulator(settings) {
      var Spring = require_spring();
      var merge = require_ngraph();
      var eventify2 = require_ngraph_events();
      if (settings) {
        if (settings.springCoeff !== void 0) throw new Error("springCoeff was renamed to springCoefficient");
        if (settings.dragCoeff !== void 0) throw new Error("dragCoeff was renamed to dragCoefficient");
      }
      settings = merge(settings, {
        /**
         * Ideal length for links (springs in physical model).
         */
        springLength: 10,
        /**
         * Hook's law coefficient. 1 - solid spring.
         */
        springCoefficient: 0.8,
        /**
         * Coulomb's law coefficient. It's used to repel nodes thus should be negative
         * if you make it positive nodes start attract each other :).
         */
        gravity: -12,
        /**
         * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).
         * The closer it's to 1 the more nodes algorithm will have to go through.
         * Setting it to one makes Barnes Hut simulation no different from
         * brute-force forces calculation (each node is considered).
         */
        theta: 0.8,
        /**
         * Drag force coefficient. Used to slow down system, thus should be less than 1.
         * The closer it is to 0 the less tight system will be.
         */
        dragCoefficient: 0.9,
        // TODO: Need to rename this to something better. E.g. `dragCoefficient`
        /**
         * Default time step (dt) for forces integration
         */
        timeStep: 0.5,
        /**
         * Adaptive time step uses average spring length to compute actual time step:
         * See: https://twitter.com/anvaka/status/1293067160755957760
         */
        adaptiveTimeStepWeight: 0,
        /**
         * This parameter defines number of dimensions of the space where simulation
         * is performed. 
         */
        dimensions: 2,
        /**
         * In debug mode more checks are performed, this will help you catch errors
         * quickly, however for production build it is recommended to turn off this flag
         * to speed up computation.
         */
        debug: false
      });
      var factory = dimensionalCache[settings.dimensions];
      if (!factory) {
        var dimensions = settings.dimensions;
        factory = {
          Body: generateCreateBodyFunction(dimensions, settings.debug),
          createQuadTree: generateQuadTreeFunction(dimensions),
          createBounds: generateBoundsFunction(dimensions),
          createDragForce: generateCreateDragForceFunction(dimensions),
          createSpringForce: generateCreateSpringForceFunction(dimensions),
          integrate: generateIntegratorFunction(dimensions)
        };
        dimensionalCache[dimensions] = factory;
      }
      var Body = factory.Body;
      var createQuadTree = factory.createQuadTree;
      var createBounds = factory.createBounds;
      var createDragForce = factory.createDragForce;
      var createSpringForce = factory.createSpringForce;
      var integrate = factory.integrate;
      var createBody = (pos) => new Body(pos);
      var random = require_ngraph2().random(42);
      var bodies = [];
      var springs = [];
      var quadTree = createQuadTree(settings, random);
      var bounds = createBounds(bodies, settings, random);
      var springForce = createSpringForce(settings, random);
      var dragForce = createDragForce(settings);
      var totalMovement = 0;
      var forces = [];
      var forceMap = /* @__PURE__ */ new Map();
      var iterationNumber = 0;
      addForce("nbody", nbodyForce);
      addForce("spring", updateSpringForce);
      var publicApi = {
        /**
         * Array of bodies, registered with current simulator
         *
         * Note: To add new body, use addBody() method. This property is only
         * exposed for testing/performance purposes.
         */
        bodies,
        quadTree,
        /**
         * Array of springs, registered with current simulator
         *
         * Note: To add new spring, use addSpring() method. This property is only
         * exposed for testing/performance purposes.
         */
        springs,
        /**
         * Returns settings with which current simulator was initialized
         */
        settings,
        /**
         * Adds a new force to simulation
         */
        addForce,
        /**
         * Removes a force from the simulation.
         */
        removeForce,
        /**
         * Returns a map of all registered forces.
         */
        getForces,
        /**
         * Performs one step of force simulation.
         *
         * @returns {boolean} true if system is considered stable; False otherwise.
         */
        step: function() {
          for (var i = 0; i < forces.length; ++i) {
            forces[i](iterationNumber);
          }
          var movement = integrate(bodies, settings.timeStep, settings.adaptiveTimeStepWeight);
          iterationNumber += 1;
          return movement;
        },
        /**
         * Adds body to the system
         *
         * @param {ngraph.physics.primitives.Body} body physical body
         *
         * @returns {ngraph.physics.primitives.Body} added body
         */
        addBody: function(body) {
          if (!body) {
            throw new Error("Body is required");
          }
          bodies.push(body);
          return body;
        },
        /**
         * Adds body to the system at given position
         *
         * @param {Object} pos position of a body
         *
         * @returns {ngraph.physics.primitives.Body} added body
         */
        addBodyAt: function(pos) {
          if (!pos) {
            throw new Error("Body position is required");
          }
          var body = createBody(pos);
          bodies.push(body);
          return body;
        },
        /**
         * Removes body from the system
         *
         * @param {ngraph.physics.primitives.Body} body to remove
         *
         * @returns {Boolean} true if body found and removed. falsy otherwise;
         */
        removeBody: function(body) {
          if (!body) {
            return;
          }
          var idx = bodies.indexOf(body);
          if (idx < 0) {
            return;
          }
          bodies.splice(idx, 1);
          if (bodies.length === 0) {
            bounds.reset();
          }
          return true;
        },
        /**
         * Adds a spring to this simulation.
         *
         * @returns {Object} - a handle for a spring. If you want to later remove
         * spring pass it to removeSpring() method.
         */
        addSpring: function(body1, body2, springLength, springCoefficient) {
          if (!body1 || !body2) {
            throw new Error("Cannot add null spring to force simulator");
          }
          if (typeof springLength !== "number") {
            springLength = -1;
          }
          var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1);
          springs.push(spring);
          return spring;
        },
        /**
         * Returns amount of movement performed on last step() call
         */
        getTotalMovement: function() {
          return totalMovement;
        },
        /**
         * Removes spring from the system
         *
         * @param {Object} spring to remove. Spring is an object returned by addSpring
         *
         * @returns {Boolean} true if spring found and removed. falsy otherwise;
         */
        removeSpring: function(spring) {
          if (!spring) {
            return;
          }
          var idx = springs.indexOf(spring);
          if (idx > -1) {
            springs.splice(idx, 1);
            return true;
          }
        },
        getBestNewBodyPosition: function(neighbors) {
          return bounds.getBestNewPosition(neighbors);
        },
        /**
         * Returns bounding box which covers all bodies
         */
        getBBox: getBoundingBox,
        getBoundingBox,
        invalidateBBox: function() {
          console.warn("invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call");
        },
        // TODO: Move the force specific stuff to force
        gravity: function(value) {
          if (value !== void 0) {
            settings.gravity = value;
            quadTree.options({ gravity: value });
            return this;
          } else {
            return settings.gravity;
          }
        },
        theta: function(value) {
          if (value !== void 0) {
            settings.theta = value;
            quadTree.options({ theta: value });
            return this;
          } else {
            return settings.theta;
          }
        },
        /**
         * Returns pseudo-random number generator instance.
         */
        random
      };
      expose(settings, publicApi);
      eventify2(publicApi);
      return publicApi;
      function getBoundingBox() {
        bounds.update();
        return bounds.box;
      }
      function addForce(forceName, forceFunction) {
        if (forceMap.has(forceName)) throw new Error("Force " + forceName + " is already added");
        forceMap.set(forceName, forceFunction);
        forces.push(forceFunction);
      }
      function removeForce(forceName) {
        var forceIndex = forces.indexOf(forceMap.get(forceName));
        if (forceIndex < 0) return;
        forces.splice(forceIndex, 1);
        forceMap.delete(forceName);
      }
      function getForces() {
        return forceMap;
      }
      function nbodyForce() {
        if (bodies.length === 0) return;
        quadTree.insertBodies(bodies);
        var i = bodies.length;
        while (i--) {
          var body = bodies[i];
          if (!body.isPinned) {
            body.reset();
            quadTree.updateBodyForce(body);
            dragForce.update(body);
          }
        }
      }
      function updateSpringForce() {
        var i = springs.length;
        while (i--) {
          springForce.update(springs[i]);
        }
      }
    }
    function expose(settings, target) {
      for (var key in settings) {
        augment(settings, target, key);
      }
    }
    function augment(source, target, key) {
      if (!source.hasOwnProperty(key)) return;
      if (typeof target[key] === "function") {
        return;
      }
      var sourceIsNumber = Number.isFinite(source[key]);
      if (sourceIsNumber) {
        target[key] = function(value) {
          if (value !== void 0) {
            if (!Number.isFinite(value)) throw new Error("Value of " + key + " should be a valid number.");
            source[key] = value;
            return target;
          }
          return source[key];
        };
      } else {
        target[key] = function(value) {
          if (value !== void 0) {
            source[key] = value;
            return target;
          }
          return source[key];
        };
      }
    }
  }
});

// node_modules/ngraph.forcelayout/index.js
var require_ngraph3 = __commonJS({
  "node_modules/ngraph.forcelayout/index.js"(exports, module) {
    module.exports = createLayout;
    module.exports.simulator = require_createPhysicsSimulator();
    var eventify2 = require_ngraph_events();
    function createLayout(graph, physicsSettings) {
      if (!graph) {
        throw new Error("Graph structure cannot be undefined");
      }
      var createSimulator = physicsSettings && physicsSettings.createSimulator || require_createPhysicsSimulator();
      var physicsSimulator = createSimulator(physicsSettings);
      if (Array.isArray(physicsSettings)) throw new Error("Physics settings is expected to be an object");
      var nodeMass = graph.version > 19 ? defaultSetNodeMass : defaultArrayNodeMass;
      if (physicsSettings && typeof physicsSettings.nodeMass === "function") {
        nodeMass = physicsSettings.nodeMass;
      }
      var nodeBodies = /* @__PURE__ */ new Map();
      var springs = {};
      var bodiesCount = 0;
      var springTransform = physicsSimulator.settings.springTransform || noop;
      initPhysics();
      listenToEvents();
      var wasStable = false;
      var api = {
        /**
         * Performs one step of iterative layout algorithm
         *
         * @returns {boolean} true if the system should be considered stable; False otherwise.
         * The system is stable if no further call to `step()` can improve the layout.
         */
        step: function() {
          if (bodiesCount === 0) {
            updateStableStatus(true);
            return true;
          }
          var lastMove = physicsSimulator.step();
          api.lastMove = lastMove;
          api.fire("step");
          var ratio = lastMove / bodiesCount;
          var isStableNow = ratio <= 0.01;
          updateStableStatus(isStableNow);
          return isStableNow;
        },
        /**
         * For a given `nodeId` returns position
         */
        getNodePosition: function(nodeId) {
          return getInitializedBody(nodeId).pos;
        },
        /**
         * Sets position of a node to a given coordinates
         * @param {string} nodeId node identifier
         * @param {number} x position of a node
         * @param {number} y position of a node
         * @param {number=} z position of node (only if applicable to body)
         */
        setNodePosition: function(nodeId) {
          var body = getInitializedBody(nodeId);
          body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));
        },
        /**
         * @returns {Object} Link position by link id
         * @returns {Object.from} {x, y} coordinates of link start
         * @returns {Object.to} {x, y} coordinates of link end
         */
        getLinkPosition: function(linkId) {
          var spring = springs[linkId];
          if (spring) {
            return {
              from: spring.from.pos,
              to: spring.to.pos
            };
          }
        },
        /**
         * @returns {Object} area required to fit in the graph. Object contains
         * `x1`, `y1` - top left coordinates
         * `x2`, `y2` - bottom right coordinates
         */
        getGraphRect: function() {
          return physicsSimulator.getBBox();
        },
        /**
         * Iterates over each body in the layout simulator and performs a callback(body, nodeId)
         */
        forEachBody,
        /*
         * Requests layout algorithm to pin/unpin node to its current position
         * Pinned nodes should not be affected by layout algorithm and always
         * remain at their position
         */
        pinNode: function(node, isPinned) {
          var body = getInitializedBody(node.id);
          body.isPinned = !!isPinned;
        },
        /**
         * Checks whether given graph's node is currently pinned
         */
        isNodePinned: function(node) {
          return getInitializedBody(node.id).isPinned;
        },
        /**
         * Request to release all resources
         */
        dispose: function() {
          graph.off("changed", onGraphChanged);
          api.fire("disposed");
        },
        /**
         * Gets physical body for a given node id. If node is not found undefined
         * value is returned.
         */
        getBody,
        /**
         * Gets spring for a given edge.
         *
         * @param {string} linkId link identifer. If two arguments are passed then
         * this argument is treated as formNodeId
         * @param {string=} toId when defined this parameter denotes head of the link
         * and first argument is treated as tail of the link (fromId)
         */
        getSpring,
        /**
         * Returns length of cumulative force vector. The closer this to zero - the more stable the system is
         */
        getForceVectorLength,
        /**
         * [Read only] Gets current physics simulator
         */
        simulator: physicsSimulator,
        /**
         * Gets the graph that was used for layout
         */
        graph,
        /**
         * Gets amount of movement performed during last step operation
         */
        lastMove: 0
      };
      eventify2(api);
      return api;
      function updateStableStatus(isStableNow) {
        if (wasStable !== isStableNow) {
          wasStable = isStableNow;
          onStableChanged(isStableNow);
        }
      }
      function forEachBody(cb) {
        nodeBodies.forEach(cb);
      }
      function getForceVectorLength() {
        var fx = 0, fy = 0;
        forEachBody(function(body) {
          fx += Math.abs(body.force.x);
          fy += Math.abs(body.force.y);
        });
        return Math.sqrt(fx * fx + fy * fy);
      }
      function getSpring(fromId, toId) {
        var linkId;
        if (toId === void 0) {
          if (typeof fromId !== "object") {
            linkId = fromId;
          } else {
            linkId = fromId.id;
          }
        } else {
          var link = graph.hasLink(fromId, toId);
          if (!link) return;
          linkId = link.id;
        }
        return springs[linkId];
      }
      function getBody(nodeId) {
        return nodeBodies.get(nodeId);
      }
      function listenToEvents() {
        graph.on("changed", onGraphChanged);
      }
      function onStableChanged(isStable) {
        api.fire("stable", isStable);
      }
      function onGraphChanged(changes) {
        for (var i = 0; i < changes.length; ++i) {
          var change = changes[i];
          if (change.changeType === "add") {
            if (change.node) {
              initBody(change.node.id);
            }
            if (change.link) {
              initLink(change.link);
            }
          } else if (change.changeType === "remove") {
            if (change.node) {
              releaseNode(change.node);
            }
            if (change.link) {
              releaseLink(change.link);
            }
          }
        }
        bodiesCount = graph.getNodesCount();
      }
      function initPhysics() {
        bodiesCount = 0;
        graph.forEachNode(function(node) {
          initBody(node.id);
          bodiesCount += 1;
        });
        graph.forEachLink(initLink);
      }
      function initBody(nodeId) {
        var body = nodeBodies.get(nodeId);
        if (!body) {
          var node = graph.getNode(nodeId);
          if (!node) {
            throw new Error("initBody() was called with unknown node id");
          }
          var pos = node.position;
          if (!pos) {
            var neighbors = getNeighborBodies(node);
            pos = physicsSimulator.getBestNewBodyPosition(neighbors);
          }
          body = physicsSimulator.addBodyAt(pos);
          body.id = nodeId;
          nodeBodies.set(nodeId, body);
          updateBodyMass(nodeId);
          if (isNodeOriginallyPinned(node)) {
            body.isPinned = true;
          }
        }
      }
      function releaseNode(node) {
        var nodeId = node.id;
        var body = nodeBodies.get(nodeId);
        if (body) {
          nodeBodies.delete(nodeId);
          physicsSimulator.removeBody(body);
        }
      }
      function initLink(link) {
        updateBodyMass(link.fromId);
        updateBodyMass(link.toId);
        var fromBody = nodeBodies.get(link.fromId), toBody = nodeBodies.get(link.toId), spring = physicsSimulator.addSpring(fromBody, toBody, link.length);
        springTransform(link, spring);
        springs[link.id] = spring;
      }
      function releaseLink(link) {
        var spring = springs[link.id];
        if (spring) {
          var from = graph.getNode(link.fromId), to = graph.getNode(link.toId);
          if (from) updateBodyMass(from.id);
          if (to) updateBodyMass(to.id);
          delete springs[link.id];
          physicsSimulator.removeSpring(spring);
        }
      }
      function getNeighborBodies(node) {
        var neighbors = [];
        if (!node.links) {
          return neighbors;
        }
        var maxNeighbors = Math.min(node.links.length, 2);
        for (var i = 0; i < maxNeighbors; ++i) {
          var link = node.links[i];
          var otherBody = link.fromId !== node.id ? nodeBodies.get(link.fromId) : nodeBodies.get(link.toId);
          if (otherBody && otherBody.pos) {
            neighbors.push(otherBody);
          }
        }
        return neighbors;
      }
      function updateBodyMass(nodeId) {
        var body = nodeBodies.get(nodeId);
        body.mass = nodeMass(nodeId);
        if (Number.isNaN(body.mass)) {
          throw new Error("Node mass should be a number");
        }
      }
      function isNodeOriginallyPinned(node) {
        return node && (node.isPinned || node.data && node.data.isPinned);
      }
      function getInitializedBody(nodeId) {
        var body = nodeBodies.get(nodeId);
        if (!body) {
          initBody(nodeId);
          body = nodeBodies.get(nodeId);
        }
        return body;
      }
      function defaultArrayNodeMass(nodeId) {
        var links = graph.getLinks(nodeId);
        if (!links) return 1;
        return 1 + links.length / 3;
      }
      function defaultSetNodeMass(nodeId) {
        var links = graph.getLinks(nodeId);
        if (!links) return 1;
        return 1 + links.size / 3;
      }
    }
    function noop() {
    }
  }
});

// node_modules/three/examples/jsm/controls/DragControls.js
var _plane = new Plane();
var _pointer = new Vector2();
var _offset = new Vector3();
var _diff = new Vector2();
var _previousPointer = new Vector2();
var _intersection = new Vector3();
var _worldPosition = new Vector3();
var _inverseMatrix = new Matrix4();
var _up = new Vector3();
var _right = new Vector3();
var _selected = null;
var _hovered = null;
var _intersections = [];
var STATE = {
  NONE: -1,
  PAN: 0,
  ROTATE: 1
};
var DragControls = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Array<Object3D>} objects - An array of draggable 3D objects.
   * @param {Camera} camera - The camera of the rendered scene.
   * @param {?HTMLElement} [domElement=null] - The HTML DOM element used for event listeners.
   */
  constructor(objects, camera2, domElement = null) {
    super(camera2, domElement);
    this.objects = objects;
    this.recursive = true;
    this.transformGroup = false;
    this.rotateSpeed = 1;
    this.raycaster = new Raycaster();
    this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.PAN, RIGHT: MOUSE.ROTATE };
    this.touches = { ONE: TOUCH.PAN };
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerCancel = onPointerCancel.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    if (domElement !== null) {
      this.connect(domElement);
    }
  }
  connect(element) {
    super.connect(element);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointerup", this._onPointerCancel);
    this.domElement.addEventListener("pointerleave", this._onPointerCancel);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointerup", this._onPointerCancel);
    this.domElement.removeEventListener("pointerleave", this._onPointerCancel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "auto";
    this.domElement.style.cursor = "";
  }
  dispose() {
    this.disconnect();
  }
  _updatePointer(event) {
    const rect = this.domElement.getBoundingClientRect();
    _pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;
    _pointer.y = -(event.clientY - rect.top) / rect.height * 2 + 1;
  }
  _updateState(event) {
    let action;
    if (event.pointerType === "touch") {
      action = this.touches.ONE;
    } else {
      switch (event.button) {
        case 0:
          action = this.mouseButtons.LEFT;
          break;
        case 1:
          action = this.mouseButtons.MIDDLE;
          break;
        case 2:
          action = this.mouseButtons.RIGHT;
          break;
        default:
          action = null;
      }
    }
    switch (action) {
      case MOUSE.PAN:
      case TOUCH.PAN:
        this.state = STATE.PAN;
        break;
      case MOUSE.ROTATE:
      case TOUCH.ROTATE:
        this.state = STATE.ROTATE;
        break;
      default:
        this.state = STATE.NONE;
    }
  }
};
function onPointerMove(event) {
  const camera2 = this.object;
  const domElement = this.domElement;
  const raycaster = this.raycaster;
  if (this.enabled === false) return;
  this._updatePointer(event);
  raycaster.setFromCamera(_pointer, camera2);
  if (_selected) {
    if (this.state === STATE.PAN) {
      if (raycaster.ray.intersectPlane(_plane, _intersection)) {
        _selected.position.copy(_intersection.sub(_offset).applyMatrix4(_inverseMatrix));
        this.dispatchEvent({ type: "drag", object: _selected });
      }
    } else if (this.state === STATE.ROTATE) {
      _diff.subVectors(_pointer, _previousPointer).multiplyScalar(this.rotateSpeed);
      _selected.rotateOnWorldAxis(_up, _diff.x);
      _selected.rotateOnWorldAxis(_right.normalize(), -_diff.y);
      this.dispatchEvent({ type: "drag", object: _selected });
    }
    _previousPointer.copy(_pointer);
  } else {
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      _intersections.length = 0;
      raycaster.setFromCamera(_pointer, camera2);
      raycaster.intersectObjects(this.objects, this.recursive, _intersections);
      if (_intersections.length > 0) {
        const object = _intersections[0].object;
        _plane.setFromNormalAndCoplanarPoint(camera2.getWorldDirection(_plane.normal), _worldPosition.setFromMatrixPosition(object.matrixWorld));
        if (_hovered !== object && _hovered !== null) {
          this.dispatchEvent({ type: "hoveroff", object: _hovered });
          domElement.style.cursor = "auto";
          _hovered = null;
        }
        if (_hovered !== object) {
          this.dispatchEvent({ type: "hoveron", object });
          domElement.style.cursor = "pointer";
          _hovered = object;
        }
      } else {
        if (_hovered !== null) {
          this.dispatchEvent({ type: "hoveroff", object: _hovered });
          domElement.style.cursor = "auto";
          _hovered = null;
        }
      }
    }
  }
  _previousPointer.copy(_pointer);
}
function onPointerDown(event) {
  const camera2 = this.object;
  const domElement = this.domElement;
  const raycaster = this.raycaster;
  if (this.enabled === false) return;
  this._updatePointer(event);
  this._updateState(event);
  _intersections.length = 0;
  raycaster.setFromCamera(_pointer, camera2);
  raycaster.intersectObjects(this.objects, this.recursive, _intersections);
  if (_intersections.length > 0) {
    if (this.transformGroup === true) {
      _selected = findGroup(_intersections[0].object);
    } else {
      _selected = _intersections[0].object;
    }
    _plane.setFromNormalAndCoplanarPoint(camera2.getWorldDirection(_plane.normal), _worldPosition.setFromMatrixPosition(_selected.matrixWorld));
    if (raycaster.ray.intersectPlane(_plane, _intersection)) {
      if (this.state === STATE.PAN) {
        _inverseMatrix.copy(_selected.parent.matrixWorld).invert();
        _offset.copy(_intersection).sub(_worldPosition.setFromMatrixPosition(_selected.matrixWorld));
        domElement.style.cursor = "move";
        this.dispatchEvent({ type: "dragstart", object: _selected });
      } else if (this.state === STATE.ROTATE) {
        _up.set(0, 1, 0).applyQuaternion(camera2.quaternion).normalize();
        _right.set(1, 0, 0).applyQuaternion(camera2.quaternion).normalize();
        domElement.style.cursor = "move";
        this.dispatchEvent({ type: "dragstart", object: _selected });
      }
    }
  }
  _previousPointer.copy(_pointer);
}
function onPointerCancel() {
  if (this.enabled === false) return;
  if (_selected) {
    this.dispatchEvent({ type: "dragend", object: _selected });
    _selected = null;
  }
  this.domElement.style.cursor = _hovered ? "pointer" : "auto";
  this.state = STATE.NONE;
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function findGroup(obj, group = null) {
  if (obj.isGroup) group = obj;
  if (obj.parent === null) return group;
  return findGroup(obj.parent, group);
}

// node_modules/d3-force-3d/src/center.js
function center_default(x2, y2, z2) {
  var nodes, strength = 1;
  if (x2 == null) x2 = 0;
  if (y2 == null) y2 = 0;
  if (z2 == null) z2 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0, sz = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
    }
    for (sx = (sx / n - x2) * strength, sy = (sy / n - y2) * strength, sz = (sz / n - z2) * strength, i = 0; i < n; ++i) {
      node = nodes[i];
      if (sx) {
        node.x -= sx;
      }
      if (sy) {
        node.y -= sy;
      }
      if (sz) {
        node.z -= sz;
      }
    }
  }
  force.initialize = function(_) {
    nodes = _;
  };
  force.x = function(_) {
    return arguments.length ? (x2 = +_, force) : x2;
  };
  force.y = function(_) {
    return arguments.length ? (y2 = +_, force) : y2;
  };
  force.z = function(_) {
    return arguments.length ? (z2 = +_, force) : z2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  return force;
}

// node_modules/d3-binarytree/src/add.js
function add_default(d) {
  const x2 = +this._x.call(null, d);
  return add(this.cover(x2), x2, d);
}
function add(tree, x2, d) {
  if (isNaN(x2)) return tree;
  var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, x1 = tree._x1, xm, xp, right, i, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (parent = node, !(node = node[i = +right])) return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  if (x2 === xp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(2) : tree._root = new Array(2);
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
  } while ((i = +right) === (j = +(xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n = data.length;
  const xz = new Float64Array(n);
  let x0 = Infinity, x1 = -Infinity;
  for (let i = 0, x2; i < n; ++i) {
    if (isNaN(x2 = +this._x.call(null, data[i]))) continue;
    xz[i] = x2;
    if (x2 < x0) x0 = x2;
    if (x2 > x1) x1 = x2;
  }
  if (x0 > x1) return this;
  this.cover(x0).cover(x1);
  for (let i = 0; i < n; ++i) {
    add(this, xz[i], data[i]);
  }
  return this;
}

// node_modules/d3-binarytree/src/cover.js
function cover_default(x2) {
  if (isNaN(x2 = +x2)) return this;
  var x0 = this._x0, x1 = this._x1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i;
    while (x0 > x2 || x2 >= x1) {
      i = +(x2 < x0);
      parent = new Array(2), parent[i] = node, node = parent, z2 *= 2;
      switch (i) {
        case 0:
          x1 = x0 + z2;
          break;
        case 1:
          x0 = x1 - z2;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._x1 = x1;
  return this;
}

// node_modules/d3-binarytree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-binarytree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0]).cover(+_[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}

// node_modules/d3-binarytree/src/half.js
function half_default(node, x0, x1) {
  this.node = node;
  this.x0 = x0;
  this.x1 = x1;
}

// node_modules/d3-binarytree/src/find.js
function find_default(x2, radius) {
  var data, x0 = this._x0, x1, x22, x3 = this._x1, halves = [], node = this._root, q, i;
  if (node) halves.push(new half_default(node, x0, x3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x2 - radius;
    x3 = x2 + radius;
  }
  while (q = halves.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x3 || (x22 = q.x1) < x0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2;
      halves.push(
        new half_default(node[1], xm, x22),
        new half_default(node[0], x1, xm)
      );
      if (i = +(x2 >= xm)) {
        q = halves[halves.length - 1];
        halves[halves.length - 1] = halves[halves.length - 1 - i];
        halves[halves.length - 1 - i] = q;
      }
    } else {
      var d = Math.abs(x2 - +this._x.call(null, node.data));
      if (d < radius) {
        radius = d;
        x0 = x2 - d;
        x3 = x2 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-binarytree/src/remove.js
function remove_default(d) {
  if (isNaN(x2 = +this._x.call(null, d))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x2, xm, right, i, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (!(parent = node, node = node[i = +right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 1]) retainer = parent, j = i;
  }
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1]) && node === (parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

// node_modules/d3-binarytree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-binarytree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}

// node_modules/d3-binarytree/src/visit.js
function visit_default(callback) {
  var halves = [], q, node = this._root, child, x0, x1;
  if (node) halves.push(new half_default(node, this._x0, this._x1));
  while (q = halves.pop()) {
    if (!callback(node = q.node, x0 = q.x0, x1 = q.x1) && node.length) {
      var xm = (x0 + x1) / 2;
      if (child = node[1]) halves.push(new half_default(child, xm, x1));
      if (child = node[0]) halves.push(new half_default(child, x0, xm));
    }
  }
  return this;
}

// node_modules/d3-binarytree/src/visitAfter.js
function visitAfter_default(callback) {
  var halves = [], next = [], q;
  if (this._root) halves.push(new half_default(this._root, this._x0, this._x1));
  while (q = halves.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, x1 = q.x1, xm = (x0 + x1) / 2;
      if (child = node[0]) halves.push(new half_default(child, x0, xm));
      if (child = node[1]) halves.push(new half_default(child, xm, x1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.x1);
  }
  return this;
}

// node_modules/d3-binarytree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-binarytree/src/binarytree.js
function binarytree(nodes, x2) {
  var tree = new Binarytree(x2 == null ? defaultX : x2, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Binarytree(x2, x0, x1) {
  this._x = x2;
  this._x0 = x0;
  this._x1 = x1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy;
}
var treeProto = binarytree.prototype = Binarytree.prototype;
treeProto.copy = function() {
  var copy = new Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(2) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 2; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(2) });
        else node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;

// node_modules/d3-quadtree/src/add.js
function add_default2(d) {
  const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
  return add2(this.cover(x2, y2), x2, y2, d);
}
function add2(tree, x2, y2, d) {
  if (isNaN(x2) || isNaN(y2)) return tree;
  var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x2 === xp && y2 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll2(data) {
  var d, i, n = data.length, x2, y2, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x2 = +this._x.call(null, d = data[i])) || isNaN(y2 = +this._y.call(null, d))) continue;
    xz[i] = x2;
    yz[i] = y2;
    if (x2 < x0) x0 = x2;
    if (x2 > x1) x1 = x2;
    if (y2 < y0) y0 = y2;
    if (y2 > y1) y1 = y2;
  }
  if (x0 > x1 || y0 > y1) return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i = 0; i < n; ++i) {
    add2(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default2(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2)) return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
    y1 = (y0 = Math.floor(y2)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i;
    while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1) {
      i = (y2 < y0) << 1 | x2 < x0;
      parent = new Array(4), parent[i] = node, node = parent, z2 *= 2;
      switch (i) {
        case 0:
          x1 = x0 + z2, y1 = y0 + z2;
          break;
        case 1:
          x0 = x1 - z2, y1 = y0 + z2;
          break;
        case 2:
          x1 = x0 + z2, y0 = y1 - z2;
          break;
        case 3:
          x0 = x1 - z2, y0 = y1 - z2;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default2(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default2(x2, y2, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
  if (node) quads.push(new quad_default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x2 - radius, y0 = y2 - radius;
    x3 = x2 + radius, y3 = y2 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i = (y2 >= ym) << 1 | x2 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x2 - d, y0 = y2 - d;
        x3 = x2 + d, y3 = y2 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default2(d) {
  if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x2, y2, xm, ym, right, bottom, i, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  }
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll2(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default2() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default2(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default2(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX2(d) {
  return d[0];
}
function x_default2(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x2, y2) {
  var tree = new Quadtree(x2 == null ? defaultX2 : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x2, y2, x0, y0, x1, y1) {
  this._x = x2;
  this._y = y2;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy2(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy;
}
var treeProto2 = quadtree.prototype = Quadtree.prototype;
treeProto2.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy2(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else node.target[i] = leaf_copy2(child);
      }
    }
  }
  return copy;
};
treeProto2.add = add_default2;
treeProto2.addAll = addAll2;
treeProto2.cover = cover_default2;
treeProto2.data = data_default2;
treeProto2.extent = extent_default2;
treeProto2.find = find_default2;
treeProto2.remove = remove_default2;
treeProto2.removeAll = removeAll2;
treeProto2.root = root_default2;
treeProto2.size = size_default2;
treeProto2.visit = visit_default2;
treeProto2.visitAfter = visitAfter_default2;
treeProto2.x = x_default2;
treeProto2.y = y_default;

// node_modules/d3-force-3d/src/constant.js
function constant_default(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-force-3d/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force-3d/src/link.js
function index4(d) {
  return d.index;
}
function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id = index4, strength = defaultStrength, strengths, distance = constant_default(30), distances, nodes, nDim, count, bias, random, iterations = 1;
  if (links == null) links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x2 = 0, y2 = 0, z2 = 0, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x2 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        if (nDim > 1) {
          y2 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        }
        if (nDim > 2) {
          z2 = target.z + target.vz - source.z - source.vz || jiggle_default(random);
        }
        l = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x2 *= l, y2 *= l, z2 *= l;
        target.vx -= x2 * (b = bias[i]);
        if (nDim > 1) {
          target.vy -= y2 * b;
        }
        if (nDim > 2) {
          target.vz -= z2 * b;
        }
        source.vx += x2 * (b = 1 - b);
        if (nDim > 1) {
          source.vy += y2 * b;
        }
        if (nDim > 2) {
          source.vz += z2 * b;
        }
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id(d, i2, nodes), d])), link;
    for (i = 0, count = new Array(n); i < m2; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m2); i < m2; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default(+_), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-force-3d/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}

// node_modules/d3-force-3d/src/simulation.js
var MAX_DIMENSIONS = 3;
function x(d) {
  return d.x;
}
function y(d) {
  return d.y;
}
function z(d) {
  return d.z;
}
var initialRadius = 10;
var initialAngleRoll = Math.PI * (3 - Math.sqrt(5));
var initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221));
function simulation_default(nodes, numDimensions) {
  numDimensions = numDimensions || 2;
  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))), simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null) nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i, n = nodes.length, node;
    if (iterations === void 0) iterations = 1;
    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (nDim > 1) {
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
        if (nDim > 2) {
          if (node.fz == null) node.z += node.vz *= velocityDecay;
          else node.z = node.fz, node.vz = 0;
        }
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (node.fz != null) node.z = node.fz;
      if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && isNaN(node.z)) {
        var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i) : nDim > 1 ? Math.sqrt(0.5 + i) : i), rollAngle = i * initialAngleRoll, yawAngle = i * initialAngleYaw;
        if (nDim === 1) {
          node.x = radius;
        } else if (nDim === 2) {
          node.x = radius * Math.cos(rollAngle);
          node.y = radius * Math.sin(rollAngle);
        } else {
          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
          node.y = radius * Math.cos(rollAngle);
          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
        }
      }
      if (isNaN(node.vx) || nDim > 1 && isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {
        node.vx = 0;
        if (nDim > 1) {
          node.vy = 0;
        }
        if (nDim > 2) {
          node.vz = 0;
        }
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random, nDim);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    numDimensions: function(_) {
      return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_))), forces.forEach(initializeForce), simulation) : nDim;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function() {
      var args = Array.prototype.slice.call(arguments);
      var x2 = args.shift() || 0, y2 = (nDim > 1 ? args.shift() : null) || 0, z2 = (nDim > 2 ? args.shift() : null) || 0, radius = args.shift() || Infinity;
      var i = 0, n = nodes.length, dx, dy, dz, d2, node, closest;
      radius *= radius;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x2 - node.x;
        dy = y2 - (node.y || 0);
        dz = z2 - (node.z || 0);
        d2 = dx * dx + dy * dy + dz * dz;
        if (d2 < radius) closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force-3d/src/manyBody.js
function manyBody_default() {
  var nodes, nDim, node, random, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i, n = nodes.length, tree = (nDim === 1 ? binarytree(nodes, x) : nDim === 2 ? quadtree(nodes, x, y) : nDim === 3 ? octree(nodes, x, y, z) : null).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(treeNode) {
    var strength2 = 0, q, c2, weight = 0, x2, y2, z2, i;
    var numChildren = treeNode.length;
    if (numChildren) {
      for (x2 = y2 = z2 = i = 0; i < numChildren; ++i) {
        if ((q = treeNode[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x2 += c2 * (q.x || 0), y2 += c2 * (q.y || 0), z2 += c2 * (q.z || 0);
        }
      }
      strength2 *= Math.sqrt(4 / numChildren);
      treeNode.x = x2 / weight;
      if (nDim > 1) {
        treeNode.y = y2 / weight;
      }
      if (nDim > 2) {
        treeNode.z = z2 / weight;
      }
    } else {
      q = treeNode;
      q.x = q.data.x;
      if (nDim > 1) {
        q.y = q.data.y;
      }
      if (nDim > 2) {
        q.z = q.data.z;
      }
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    treeNode.value = strength2;
  }
  function apply(treeNode, x1, arg1, arg2, arg3) {
    if (!treeNode.value) return true;
    var x2 = [arg1, arg2, arg3][nDim - 1];
    var x3 = treeNode.x - node.x, y2 = nDim > 1 ? treeNode.y - node.y : 0, z2 = nDim > 2 ? treeNode.z - node.z : 0, w = x2 - x1, l = x3 * x3 + y2 * y2 + z2 * z2;
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0) x3 = jiggle_default(random), l += x3 * x3;
        if (nDim > 1 && y2 === 0) y2 = jiggle_default(random), l += y2 * y2;
        if (nDim > 2 && z2 === 0) z2 = jiggle_default(random), l += z2 * z2;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x3 * treeNode.value * alpha / l;
        if (nDim > 1) {
          node.vy += y2 * treeNode.value * alpha / l;
        }
        if (nDim > 2) {
          node.vz += z2 * treeNode.value * alpha / l;
        }
      }
      return true;
    } else if (treeNode.length || l >= distanceMax2) return;
    if (treeNode.data !== node || treeNode.next) {
      if (x3 === 0) x3 = jiggle_default(random), l += x3 * x3;
      if (nDim > 1 && y2 === 0) y2 = jiggle_default(random), l += y2 * y2;
      if (nDim > 2 && z2 === 0) z2 = jiggle_default(random), l += z2 * z2;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (treeNode.data !== node) {
        w = strengths[treeNode.data.index] * alpha / l;
        node.vx += x3 * w;
        if (nDim > 1) {
          node.vy += y2 * w;
        }
        if (nDim > 2) {
          node.vz += z2 * w;
        }
      }
    while (treeNode = treeNode.next);
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force-3d/src/radial.js
function radial_default(radius, x2, y2, z2) {
  var nodes, nDim, strength = constant_default(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant_default(+radius);
  if (x2 == null) x2 = 0;
  if (y2 == null) y2 = 0;
  if (z2 == null) z2 = 0;
  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i], dx = node.x - x2 || 1e-6, dy = (node.y || 0) - y2 || 1e-6, dz = (node.z || 0) - z2 || 1e-6, r = Math.sqrt(dx * dx + dy * dy + dz * dz), k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      if (nDim > 1) {
        node.vy += dy * k;
      }
      if (nDim > 2) {
        node.vz += dz * k;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(initNodes, ...args) {
    nodes = initNodes;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : radius;
  };
  force.x = function(_) {
    return arguments.length ? (x2 = +_, force) : x2;
  };
  force.y = function(_) {
    return arguments.length ? (y2 = +_, force) : y2;
  };
  force.z = function(_) {
    return arguments.length ? (z2 = +_, force) : z2;
  };
  return force;
}

// node_modules/ngraph.events/index.js
function eventify(subject) {
  validateSubject(subject);
  const eventsStorage = createEventsStorage(subject);
  subject.on = eventsStorage.on;
  subject.off = eventsStorage.off;
  subject.fire = eventsStorage.fire;
  return subject;
}
function createEventsStorage(subject) {
  let registeredEvents = /* @__PURE__ */ Object.create(null);
  return {
    on: function(eventName, callback, ctx) {
      if (typeof callback !== "function") {
        throw new Error("callback is expected to be a function");
      }
      let handlers = registeredEvents[eventName];
      if (!handlers) {
        handlers = registeredEvents[eventName] = [];
      }
      handlers.push({ callback, ctx });
      return subject;
    },
    off: function(eventName, callback) {
      const wantToRemoveAll = typeof eventName === "undefined";
      if (wantToRemoveAll) {
        registeredEvents = /* @__PURE__ */ Object.create(null);
        return subject;
      }
      if (registeredEvents[eventName]) {
        const deleteAllCallbacksForEvent = typeof callback !== "function";
        if (deleteAllCallbacksForEvent) {
          delete registeredEvents[eventName];
        } else {
          const callbacks = registeredEvents[eventName];
          for (let i = 0; i < callbacks.length; ++i) {
            if (callbacks[i].callback === callback) {
              callbacks.splice(i, 1);
            }
          }
        }
      }
      return subject;
    },
    fire: function(eventName) {
      const callbacks = registeredEvents[eventName];
      if (!callbacks) {
        return subject;
      }
      let fireArguments;
      if (arguments.length > 1) {
        fireArguments = Array.prototype.slice.call(arguments, 1);
      }
      for (let i = 0; i < callbacks.length; ++i) {
        const callbackInfo = callbacks[i];
        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
      }
      return subject;
    }
  };
}
function validateSubject(subject) {
  if (!subject) {
    throw new Error("Eventify cannot use falsy object as events subject");
  }
  const reservedWords = ["on", "fire", "off"];
  for (let i = 0; i < reservedWords.length; ++i) {
    if (subject.hasOwnProperty(reservedWords[i])) {
      throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i] + "'");
    }
  }
}

// node_modules/ngraph.graph/index.js
var ngraph_default = createGraph;
function createGraph(options) {
  options = options || {};
  if ("uniqueLinkId" in options) {
    console.warn(
      "ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n",
      "\n",
      "Note: there is also change in default behavior: From now on each graph\nis considered to be not a multigraph by default (each edge is unique)."
    );
    options.multigraph = options.uniqueLinkId;
  }
  if (options.multigraph === void 0) options.multigraph = false;
  if (typeof Map !== "function") {
    throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
  }
  var nodes = /* @__PURE__ */ new Map();
  var links = /* @__PURE__ */ new Map();
  var multiEdges = {};
  var suspendEvents = 0;
  var createLink = options.multigraph ? createUniqueLink : createSingleLink, changes = [], recordLinkChange = noop, recordNodeChange = noop, enterModification = noop, exitModification = noop;
  var graphPart = {
    /**
     * Sometimes duck typing could be slow. Giving clients a hint about data structure
     * via explicit version number here:
     */
    version: 20,
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode,
    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink,
    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink,
    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode,
    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode,
    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount,
    /**
     * Gets total number of links in the graph.
     */
    getLinkCount,
    /**
     * Synonym for `getLinkCount()`
     */
    getEdgeCount: getLinkCount,
    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: getLinkCount,
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: getNodeCount,
    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Set of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks,
    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode,
    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode,
    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink,
    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: enterModification,
    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: exitModification,
    /**
     * Removes all nodes and links from the graph.
     */
    clear,
    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonym for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: getLink,
    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonym for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: getNode,
    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLink,
    /**
     * Gets a link by its id.
     *
     * @param {string} linkId link identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLinkById
  };
  eventify(graphPart);
  monitorSubscribers();
  return graphPart;
  function monitorSubscribers() {
    var realOn = graphPart.on;
    graphPart.on = on;
    function on() {
      graphPart.beginUpdate = enterModification = enterModificationReal;
      graphPart.endUpdate = exitModification = exitModificationReal;
      recordLinkChange = recordLinkChangeReal;
      recordNodeChange = recordNodeChangeReal;
      graphPart.on = realOn;
      return realOn.apply(graphPart, arguments);
    }
  }
  function recordLinkChangeReal(link, changeType) {
    changes.push({
      link,
      changeType
    });
  }
  function recordNodeChangeReal(node, changeType) {
    changes.push({
      node,
      changeType
    });
  }
  function addNode(nodeId, data) {
    if (nodeId === void 0) {
      throw new Error("Invalid node identifier");
    }
    enterModification();
    var node = getNode(nodeId);
    if (!node) {
      node = new Node(nodeId, data);
      recordNodeChange(node, "add");
    } else {
      node.data = data;
      recordNodeChange(node, "update");
    }
    nodes.set(nodeId, node);
    exitModification();
    return node;
  }
  function getNode(nodeId) {
    return nodes.get(nodeId);
  }
  function removeNode(nodeId) {
    var node = getNode(nodeId);
    if (!node) {
      return false;
    }
    enterModification();
    var prevLinks = node.links;
    if (prevLinks) {
      prevLinks.forEach(removeLinkInstance);
      node.links = null;
    }
    nodes.delete(nodeId);
    recordNodeChange(node, "remove");
    exitModification();
    return true;
  }
  function addLink(fromId, toId, data) {
    enterModification();
    var fromNode = getNode(fromId) || addNode(fromId);
    var toNode = getNode(toId) || addNode(toId);
    var link = createLink(fromId, toId, data);
    var isUpdate = links.has(link.id);
    links.set(link.id, link);
    addLinkToNode(fromNode, link);
    if (fromId !== toId) {
      addLinkToNode(toNode, link);
    }
    recordLinkChange(link, isUpdate ? "update" : "add");
    exitModification();
    return link;
  }
  function createSingleLink(fromId, toId, data) {
    var linkId = makeLinkId(fromId, toId);
    var prevLink = links.get(linkId);
    if (prevLink) {
      prevLink.data = data;
      return prevLink;
    }
    return new Link(fromId, toId, data, linkId);
  }
  function createUniqueLink(fromId, toId, data) {
    var linkId = makeLinkId(fromId, toId);
    var isMultiEdge = multiEdges.hasOwnProperty(linkId);
    if (isMultiEdge || getLink(fromId, toId)) {
      if (!isMultiEdge) {
        multiEdges[linkId] = 0;
      }
      var suffix = "@" + ++multiEdges[linkId];
      linkId = makeLinkId(fromId + suffix, toId + suffix);
    }
    return new Link(fromId, toId, data, linkId);
  }
  function getNodeCount() {
    return nodes.size;
  }
  function getLinkCount() {
    return links.size;
  }
  function getLinks(nodeId) {
    var node = getNode(nodeId);
    return node ? node.links : null;
  }
  function removeLink(link, otherId) {
    if (otherId !== void 0) {
      link = getLink(link, otherId);
    }
    return removeLinkInstance(link);
  }
  function removeLinkInstance(link) {
    if (!link) {
      return false;
    }
    if (!links.get(link.id)) return false;
    enterModification();
    links.delete(link.id);
    var fromNode = getNode(link.fromId);
    var toNode = getNode(link.toId);
    if (fromNode) {
      fromNode.links.delete(link);
    }
    if (toNode) {
      toNode.links.delete(link);
    }
    recordLinkChange(link, "remove");
    exitModification();
    return true;
  }
  function getLink(fromNodeId, toNodeId) {
    if (fromNodeId === void 0 || toNodeId === void 0) return void 0;
    return links.get(makeLinkId(fromNodeId, toNodeId));
  }
  function getLinkById(linkId) {
    if (linkId === void 0) return void 0;
    return links.get(linkId);
  }
  function clear() {
    enterModification();
    forEachNode(function(node) {
      removeNode(node.id);
    });
    exitModification();
  }
  function forEachLink(callback) {
    if (typeof callback === "function") {
      var valuesIterator = links.values();
      var nextValue = valuesIterator.next();
      while (!nextValue.done) {
        if (callback(nextValue.value)) {
          return true;
        }
        nextValue = valuesIterator.next();
      }
    }
  }
  function forEachLinkedNode(nodeId, callback, oriented) {
    var node = getNode(nodeId);
    if (node && node.links && typeof callback === "function") {
      if (oriented) {
        return forEachOrientedLink(node.links, nodeId, callback);
      } else {
        return forEachNonOrientedLink(node.links, nodeId, callback);
      }
    }
  }
  function forEachNonOrientedLink(links2, nodeId, callback) {
    var quitFast;
    var valuesIterator = links2.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      var link = nextValue.value;
      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;
      quitFast = callback(nodes.get(linkedNodeId), link);
      if (quitFast) {
        return true;
      }
      nextValue = valuesIterator.next();
    }
  }
  function forEachOrientedLink(links2, nodeId, callback) {
    var quitFast;
    var valuesIterator = links2.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      var link = nextValue.value;
      if (link.fromId === nodeId) {
        quitFast = callback(nodes.get(link.toId), link);
        if (quitFast) {
          return true;
        }
      }
      nextValue = valuesIterator.next();
    }
  }
  function noop() {
  }
  function enterModificationReal() {
    suspendEvents += 1;
  }
  function exitModificationReal() {
    suspendEvents -= 1;
    if (suspendEvents === 0 && changes.length > 0) {
      graphPart.fire("changed", changes);
      changes.length = 0;
    }
  }
  function forEachNode(callback) {
    if (typeof callback !== "function") {
      throw new Error("Function is expected to iterate over graph nodes. You passed " + callback);
    }
    var valuesIterator = nodes.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      if (callback(nextValue.value)) {
        return true;
      }
      nextValue = valuesIterator.next();
    }
  }
}
function Node(id, data) {
  this.id = id;
  this.links = null;
  this.data = data;
}
function addLinkToNode(node, link) {
  if (node.links) {
    node.links.add(link);
  } else {
    node.links = /* @__PURE__ */ new Set([link]);
  }
}
function Link(fromId, toId, data, id) {
  this.fromId = fromId;
  this.toId = toId;
  this.data = data;
  this.id = id;
}
function makeLinkId(fromId, toId) {
  return fromId.toString() + "ð " + toId.toString();
}

// node_modules/three-forcegraph/dist/three-forcegraph.mjs
var import_ngraph3 = __toESM(require_ngraph3(), 1);
function _arrayLikeToArray(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck(a2, n) {
  if (!(a2 instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet2(s, a2) {
  return s.get(_assertClassBrand(s, a2));
}
function _classPrivateFieldInitSpec(e, t, a2) {
  _checkPrivateRedeclaration(e, t), t.set(e, a2);
}
function _classPrivateFieldSet2(s, a2, r) {
  return s.set(_assertClassBrand(s, a2), r), r;
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return p;
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a2 = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
  return t;
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(t.prototype), o, e);
  return "function" == typeof p ? function(t2) {
    return p.apply(e, t2);
  } : p;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _unsupportedIterableToArray(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a2);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a2) : void 0;
  }
}
var _materialDispose = function materialDispose(material) {
  if (material instanceof Array) {
    material.forEach(_materialDispose);
  } else {
    if (material.map) {
      material.map.dispose();
    }
    material.dispose();
  }
};
var _deallocate = function deallocate(obj) {
  if (obj.geometry) {
    obj.geometry.dispose();
  }
  if (obj.material) {
    _materialDispose(obj.material);
  }
  if (obj.texture) {
    obj.texture.dispose();
  }
  if (obj.children) {
    obj.children.forEach(_deallocate);
  }
};
var emptyObject = function emptyObject2(obj) {
  while (obj.children.length) {
    var childObj = obj.children[0];
    obj.remove(childObj);
    _deallocate(childObj);
  }
};
var _dataBindAttr = /* @__PURE__ */ new WeakMap();
var _objBindAttr = /* @__PURE__ */ new WeakMap();
var ThreeDigest = function(_DataBindMapper) {
  function ThreeDigest2(scene2) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$dataBindAttr = _ref.dataBindAttr, dataBindAttr = _ref$dataBindAttr === void 0 ? "__data" : _ref$dataBindAttr, _ref$objBindAttr = _ref.objBindAttr, objBindAttr = _ref$objBindAttr === void 0 ? "__threeObj" : _ref$objBindAttr;
    _classCallCheck(this, ThreeDigest2);
    _this = _callSuper(this, ThreeDigest2);
    _defineProperty(_this, "scene", void 0);
    _classPrivateFieldInitSpec(_this, _dataBindAttr, void 0);
    _classPrivateFieldInitSpec(_this, _objBindAttr, void 0);
    _this.scene = scene2;
    _classPrivateFieldSet2(_dataBindAttr, _this, dataBindAttr);
    _classPrivateFieldSet2(_objBindAttr, _this, objBindAttr);
    _this.onRemoveObj(function() {
    });
    return _this;
  }
  _inherits(ThreeDigest2, _DataBindMapper);
  return _createClass(ThreeDigest2, [{
    key: "onCreateObj",
    value: function onCreateObj(fn) {
      var _this2 = this;
      _superPropGet(ThreeDigest2, "onCreateObj", this)([function(d) {
        var obj = fn(d);
        d[_classPrivateFieldGet2(_objBindAttr, _this2)] = obj;
        obj[_classPrivateFieldGet2(_dataBindAttr, _this2)] = d;
        _this2.scene.add(obj);
        return obj;
      }]);
      return this;
    }
  }, {
    key: "onRemoveObj",
    value: function onRemoveObj(fn) {
      var _this3 = this;
      _superPropGet(ThreeDigest2, "onRemoveObj", this)([function(obj, dId) {
        var d = _superPropGet(ThreeDigest2, "getData", _this3)([obj]);
        fn(obj, dId);
        _this3.scene.remove(obj);
        emptyObject(obj);
        delete d[_classPrivateFieldGet2(_objBindAttr, _this3)];
      }]);
      return this;
    }
  }]);
}(DataBindMapper);
var colorStr2Hex = function colorStr2Hex2(str) {
  return isNaN(str) ? parseInt(tinycolor(str).toHex(), 16) : str;
};
var colorAlpha = function colorAlpha2(str) {
  return isNaN(str) ? tinycolor(str).getAlpha() : 1;
};
var autoColorScale = ordinal(Paired_default);
function autoColorObjects(objects, colorByAccessor, colorField) {
  if (!colorByAccessor || typeof colorField !== "string") return;
  objects.filter(function(obj) {
    return !obj[colorField];
  }).forEach(function(obj) {
    obj[colorField] = autoColorScale(colorByAccessor(obj));
  });
}
function getDagDepths(_ref, idAccessor) {
  var nodes = _ref.nodes, links = _ref.links;
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$nodeFilter = _ref2.nodeFilter, nodeFilter = _ref2$nodeFilter === void 0 ? function() {
    return true;
  } : _ref2$nodeFilter, _ref2$onLoopError = _ref2.onLoopError, onLoopError = _ref2$onLoopError === void 0 ? function(loopIds) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(loopIds.join(" -> "), ".");
  } : _ref2$onLoopError;
  var graph = {};
  nodes.forEach(function(node) {
    return graph[idAccessor(node)] = {
      data: node,
      out: [],
      depth: -1,
      skip: !nodeFilter(node)
    };
  });
  links.forEach(function(_ref3) {
    var source = _ref3.source, target = _ref3.target;
    var sourceId = getNodeId(source);
    var targetId = getNodeId(target);
    if (!graph.hasOwnProperty(sourceId)) throw "Missing source node with id: ".concat(sourceId);
    if (!graph.hasOwnProperty(targetId)) throw "Missing target node with id: ".concat(targetId);
    var sourceNode = graph[sourceId];
    var targetNode = graph[targetId];
    sourceNode.out.push(targetNode);
    function getNodeId(node) {
      return _typeof(node) === "object" ? idAccessor(node) : node;
    }
  });
  var foundLoops = [];
  traverse(Object.values(graph));
  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function(_ref4) {
    var _ref5 = _slicedToArray(_ref4, 2), node = _ref5[1];
    return !node.skip;
  }).map(function(_ref6) {
    var _ref7 = _slicedToArray(_ref6, 2), id = _ref7[0], node = _ref7[1];
    return _defineProperty({}, id, node.depth);
  }))));
  return nodeDepths;
  function traverse(nodes2) {
    var nodeStack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var _loop = function _loop2() {
      var node = nodes2[i];
      if (nodeStack.indexOf(node) !== -1) {
        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function(d) {
          return idAccessor(d.data);
        });
        if (!foundLoops.some(function(foundLoop) {
          return foundLoop.length === loop.length && foundLoop.every(function(id, idx) {
            return id === loop[idx];
          });
        })) {
          foundLoops.push(loop);
          onLoopError(loop);
        }
        return 1;
      }
      if (currentDepth > node.depth) {
        node.depth = currentDepth;
        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));
      }
    };
    for (var i = 0, l = nodes2.length; i < l; i++) {
      if (_loop()) continue;
    }
  }
}
var three$1 = window.THREE ? window.THREE : {
  Group,
  Mesh,
  MeshLambertMaterial,
  Color,
  BufferGeometry,
  BufferAttribute,
  Matrix4,
  Vector3,
  SphereGeometry,
  CylinderGeometry,
  TubeGeometry,
  ConeGeometry,
  Line,
  LineBasicMaterial,
  QuadraticBezierCurve3,
  CubicBezierCurve3,
  Box3
};
var ngraph = {
  graph: ngraph_default,
  forcelayout: import_ngraph3.default
};
var DAG_LEVEL_NODE_RATIO = 2;
var setAttributeFn = new three$1.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute";
var applyMatrix4Fn = new three$1.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix";
var ForceGraph = index2({
  props: {
    jsonUrl: {
      onChange: function onChange(jsonUrl, state) {
        var _this = this;
        if (jsonUrl && !state.fetchingJson) {
          state.fetchingJson = true;
          state.onLoading();
          fetch(jsonUrl).then(function(r) {
            return r.json();
          }).then(function(json) {
            state.fetchingJson = false;
            state.onFinishLoading(json);
            _this.graphData(json);
          });
        }
      },
      triggerUpdate: false
    },
    graphData: {
      "default": {
        nodes: [],
        links: []
      },
      onChange: function onChange2(graphData, state) {
        state.engineRunning = false;
      }
    },
    numDimensions: {
      "default": 3,
      onChange: function onChange3(numDim, state) {
        var chargeForce = state.d3ForceLayout.force("charge");
        if (chargeForce) {
          chargeForce.strength(numDim > 2 ? -60 : -30);
        }
        if (numDim < 3) {
          eraseDimension(state.graphData.nodes, "z");
        }
        if (numDim < 2) {
          eraseDimension(state.graphData.nodes, "y");
        }
        function eraseDimension(nodes, dim) {
          nodes.forEach(function(d) {
            delete d[dim];
            delete d["v".concat(dim)];
          });
        }
      }
    },
    dagMode: {
      onChange: function onChange4(dagMode, state) {
        !dagMode && state.forceEngine === "d3" && (state.graphData.nodes || []).forEach(function(n) {
          return n.fx = n.fy = n.fz = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      "default": function _default(node) {
        return true;
      }
    },
    onDagError: {
      triggerUpdate: false
    },
    nodeRelSize: {
      "default": 4
    },
    // volume per val unit
    nodeId: {
      "default": "id"
    },
    nodeVal: {
      "default": "val"
    },
    nodeResolution: {
      "default": 8
    },
    // how many slice segments in the sphere's circumference
    nodeColor: {
      "default": "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      "default": 0.75
    },
    nodeVisibility: {
      "default": true
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      "default": false
    },
    nodePositionUpdate: {
      triggerUpdate: false
    },
    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.
    linkSource: {
      "default": "source"
    },
    linkTarget: {
      "default": "target"
    },
    linkVisibility: {
      "default": true
    },
    linkColor: {
      "default": "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      "default": 0.2
    },
    linkWidth: {},
    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
    linkResolution: {
      "default": 6
    },
    // how many radial segments in each line tube's geometry
    linkCurvature: {
      "default": 0,
      triggerUpdate: false
    },
    // line curvature radius (0: straight, 1: semi-circle)
    linkCurveRotation: {
      "default": 0,
      triggerUpdate: false
    },
    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      "default": false
    },
    linkPositionUpdate: {
      triggerUpdate: false
    },
    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.
    linkDirectionalArrowLength: {
      "default": 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      "default": 0.5,
      triggerUpdate: false
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      "default": 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      "default": 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      "default": 0.01,
      triggerUpdate: false
    },
    // in link length ratio per frame
    linkDirectionalParticleOffset: {
      "default": 0,
      triggerUpdate: false
    },
    // starting position offset along the link's length, like a pre-delay. Values between [0, 1]
    linkDirectionalParticleWidth: {
      "default": 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      "default": 4
    },
    // how many slice segments in the particle sphere's circumference
    linkDirectionalParticleThreeObject: {},
    forceEngine: {
      "default": "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      "default": 0
    },
    d3AlphaDecay: {
      "default": 0.0228,
      triggerUpdate: false,
      onChange: function onChange5(alphaDecay, state) {
        state.d3ForceLayout.alphaDecay(alphaDecay);
      }
    },
    d3AlphaTarget: {
      "default": 0,
      triggerUpdate: false,
      onChange: function onChange6(alphaTarget, state) {
        state.d3ForceLayout.alphaTarget(alphaTarget);
      }
    },
    d3VelocityDecay: {
      "default": 0.4,
      triggerUpdate: false,
      onChange: function onChange7(velocityDecay, state) {
        state.d3ForceLayout.velocityDecay(velocityDecay);
      }
    },
    ngraphPhysics: {
      "default": {
        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js
        timeStep: 20,
        gravity: -1.2,
        theta: 0.8,
        springLength: 30,
        springCoefficient: 8e-4,
        dragCoefficient: 0.02
      }
    },
    warmupTicks: {
      "default": 0,
      triggerUpdate: false
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      "default": Infinity,
      triggerUpdate: false
    },
    cooldownTime: {
      "default": 15e3,
      triggerUpdate: false
    },
    // ms
    onLoading: {
      "default": function _default2() {
      },
      triggerUpdate: false
    },
    onFinishLoading: {
      "default": function _default3() {
      },
      triggerUpdate: false
    },
    onUpdate: {
      "default": function _default4() {
      },
      triggerUpdate: false
    },
    onFinishUpdate: {
      "default": function _default5() {
      },
      triggerUpdate: false
    },
    onEngineTick: {
      "default": function _default6() {
      },
      triggerUpdate: false
    },
    onEngineStop: {
      "default": function _default7() {
      },
      triggerUpdate: false
    }
  },
  methods: {
    refresh: function refresh(state) {
      state._flushObjects = true;
      state._rerender();
      return this;
    },
    // Expose d3 forces for external manipulation
    d3Force: function d3Force(state, forceName, forceFn) {
      if (forceFn === void 0) {
        return state.d3ForceLayout.force(forceName);
      }
      state.d3ForceLayout.force(forceName, forceFn);
      return this;
    },
    d3ReheatSimulation: function d3ReheatSimulation(state) {
      state.d3ForceLayout.alpha(1);
      this.resetCountdown();
      return this;
    },
    // reset cooldown state
    resetCountdown: function resetCountdown(state) {
      state.cntTicks = 0;
      state.startTickTime = /* @__PURE__ */ new Date();
      state.engineRunning = true;
      return this;
    },
    tickFrame: function tickFrame(state) {
      var isD3Sim = state.forceEngine !== "ngraph";
      if (state.engineRunning) {
        layoutTick();
      }
      updateArrows();
      updatePhotons();
      return this;
      function layoutTick() {
        if (++state.cntTicks > state.cooldownTicks || /* @__PURE__ */ new Date() - state.startTickTime > state.cooldownTime || isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin) {
          state.engineRunning = false;
          state.onEngineStop();
        } else {
          state.layout[isD3Sim ? "tick" : "step"]();
          state.onEngineTick();
        }
        var nodeThreeObjectExtendAccessor = index3(state.nodeThreeObjectExtend);
        state.nodeDataMapper.entries().forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), node = _ref2[0], obj = _ref2[1];
          if (!obj) return;
          var pos = isD3Sim ? node : state.layout.getNodePosition(node[state.nodeId]);
          var extendedObj = nodeThreeObjectExtendAccessor(node);
          if (!state.nodePositionUpdate || !state.nodePositionUpdate(extendedObj ? obj.children[0] : obj, {
            x: pos.x,
            y: pos.y,
            z: pos.z
          }, node) || extendedObj) {
            obj.position.x = pos.x;
            obj.position.y = pos.y || 0;
            obj.position.z = pos.z || 0;
          }
        });
        var linkWidthAccessor = index3(state.linkWidth);
        var linkCurvatureAccessor = index3(state.linkCurvature);
        var linkCurveRotationAccessor = index3(state.linkCurveRotation);
        var linkThreeObjectExtendAccessor = index3(state.linkThreeObjectExtend);
        state.linkDataMapper.entries().forEach(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), link = _ref4[0], lineObj = _ref4[1];
          if (!lineObj) return;
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start || !end || !start.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          calcLinkCurve(link);
          var extendedObj = linkThreeObjectExtendAccessor(link);
          if (state.linkPositionUpdate && state.linkPositionUpdate(
            extendedObj ? lineObj.children[1] : lineObj,
            // pass child custom object if extending the default
            {
              start: {
                x: start.x,
                y: start.y,
                z: start.z
              },
              end: {
                x: end.x,
                y: end.y,
                z: end.z
              }
            },
            link
          ) && !extendedObj) {
            return;
          }
          var curveResolution = 30;
          var curve = link.__curve;
          var line = lineObj.children.length ? lineObj.children[0] : lineObj;
          if (line.type === "Line") {
            if (!curve) {
              var linePos = line.geometry.getAttribute("position");
              if (!linePos || !linePos.array || linePos.array.length !== 6) {
                line.geometry[setAttributeFn]("position", linePos = new three$1.BufferAttribute(new Float32Array(2 * 3), 3));
              }
              linePos.array[0] = start.x;
              linePos.array[1] = start.y || 0;
              linePos.array[2] = start.z || 0;
              linePos.array[3] = end.x;
              linePos.array[4] = end.y || 0;
              linePos.array[5] = end.z || 0;
              linePos.needsUpdate = true;
            } else {
              var curvePnts = curve.getPoints(curveResolution);
              if (line.geometry.getAttribute("position").array.length !== curvePnts.length * 3) {
                line.geometry[setAttributeFn]("position", new three$1.BufferAttribute(new Float32Array(curvePnts.length * 3), 3));
              }
              line.geometry.setFromPoints(curvePnts);
            }
            line.geometry.computeBoundingSphere();
          } else if (line.type === "Mesh") {
            if (!curve) {
              if (!line.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {
                var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;
                var r = linkWidth / 2;
                var geometry = new three$1.CylinderGeometry(r, r, 1, state.linkResolution, 1, false);
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));
                line.geometry.dispose();
                line.geometry = geometry;
              }
              var vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);
              var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);
              var distance = vStart.distanceTo(vEnd);
              line.position.x = vStart.x;
              line.position.y = vStart.y;
              line.position.z = vStart.z;
              line.scale.z = distance;
              line.parent.localToWorld(vEnd);
              line.lookAt(vEnd);
            } else {
              if (!line.geometry.type.match(/^Tube(Buffer)?Geometry$/)) {
                line.position.set(0, 0, 0);
                line.rotation.set(0, 0, 0);
                line.scale.set(1, 1, 1);
              }
              var _linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;
              var _r = _linkWidth / 2;
              var _geometry = new three$1.TubeGeometry(curve, curveResolution, _r, state.linkResolution, false);
              line.geometry.dispose();
              line.geometry = _geometry;
            }
          }
        });
        function calcLinkCurve(link) {
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start || !end || !start.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var curvature = linkCurvatureAccessor(link);
          if (!curvature) {
            link.__curve = null;
          } else {
            var vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);
            var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);
            var l = vStart.distanceTo(vEnd);
            var curve;
            var curveRotation = linkCurveRotationAccessor(link);
            if (l > 0) {
              var dx = end.x - start.x;
              var dy = end.y - start.y || 0;
              var vLine = new three$1.Vector3().subVectors(vEnd, vStart);
              var cp = vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new three$1.Vector3(0, 0, 1) : new three$1.Vector3(0, 1, 0)).applyAxisAngle(vLine.normalize(), curveRotation).add(new three$1.Vector3().addVectors(vStart, vEnd).divideScalar(2));
              curve = new three$1.QuadraticBezierCurve3(vStart, cp, vEnd);
            } else {
              var d = curvature * 70;
              var endAngle = -curveRotation;
              var startAngle = endAngle + Math.PI / 2;
              curve = new three$1.CubicBezierCurve3(vStart, new three$1.Vector3(d * Math.cos(startAngle), d * Math.sin(startAngle), 0).add(vStart), new three$1.Vector3(d * Math.cos(endAngle), d * Math.sin(endAngle), 0).add(vStart), vEnd);
            }
            link.__curve = curve;
          }
        }
      }
      function updateArrows() {
        var arrowRelPosAccessor = index3(state.linkDirectionalArrowRelPos);
        var arrowLengthAccessor = index3(state.linkDirectionalArrowLength);
        var nodeValAccessor = index3(state.nodeVal);
        state.arrowDataMapper.entries().forEach(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 2), link = _ref6[0], arrowObj = _ref6[1];
          if (!arrowObj) return;
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start || !end || !start.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var startR = Math.cbrt(Math.max(0, nodeValAccessor(start) || 1)) * state.nodeRelSize;
          var endR = Math.cbrt(Math.max(0, nodeValAccessor(end) || 1)) * state.nodeRelSize;
          var arrowLength = arrowLengthAccessor(link);
          var arrowRelPos = arrowRelPosAccessor(link);
          var getPosAlongLine = link.__curve ? function(t) {
            return link.__curve.getPoint(t);
          } : function(t) {
            var iplt = function iplt2(dim, start2, end2, t2) {
              return start2[dim] + (end2[dim] - start2[dim]) * t2 || 0;
            };
            return {
              x: iplt("x", start, end, t),
              y: iplt("y", start, end, t),
              z: iplt("z", start, end, t)
            };
          };
          var lineLen = link.__curve ? link.__curve.getLength() : Math.sqrt(["x", "y", "z"].map(function(dim) {
            return Math.pow((end[dim] || 0) - (start[dim] || 0), 2);
          }).reduce(function(acc, v) {
            return acc + v;
          }, 0));
          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
          var arrowHead = getPosAlongLine(posAlongLine / lineLen);
          var arrowTail = getPosAlongLine((posAlongLine - arrowLength) / lineLen);
          ["x", "y", "z"].forEach(function(dim) {
            return arrowObj.position[dim] = arrowTail[dim];
          });
          var headVec = _construct(three$1.Vector3, _toConsumableArray(["x", "y", "z"].map(function(c2) {
            return arrowHead[c2];
          })));
          arrowObj.parent.localToWorld(headVec);
          arrowObj.lookAt(headVec);
        });
      }
      function updatePhotons() {
        var particleSpeedAccessor = index3(state.linkDirectionalParticleSpeed);
        var particleOffsetAccessor = index3(state.linkDirectionalParticleOffset);
        state.graphData.links.forEach(function(link) {
          var photonsObj = state.particlesDataMapper.getObj(link);
          var cyclePhotons = photonsObj && photonsObj.children;
          var singleHopPhotons = link.__singleHopPhotonsObj && link.__singleHopPhotonsObj.children;
          if ((!singleHopPhotons || !singleHopPhotons.length) && (!cyclePhotons || !cyclePhotons.length)) return;
          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start = pos[isD3Sim ? "source" : "from"];
          var end = pos[isD3Sim ? "target" : "to"];
          if (!start || !end || !start.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
          var particleSpeed = particleSpeedAccessor(link);
          var particleOffset = Math.abs(particleOffsetAccessor(link));
          var getPhotonPos = link.__curve ? function(t) {
            return link.__curve.getPoint(t);
          } : function(t) {
            var iplt = function iplt2(dim, start2, end2, t2) {
              return start2[dim] + (end2[dim] - start2[dim]) * t2 || 0;
            };
            return {
              x: iplt("x", start, end, t),
              y: iplt("y", start, end, t),
              z: iplt("z", start, end, t)
            };
          };
          var photons = [].concat(_toConsumableArray(cyclePhotons || []), _toConsumableArray(singleHopPhotons || []));
          photons.forEach(function(photon, idx) {
            var singleHop = photon.parent.__linkThreeObjType === "singleHopPhotons";
            if (!photon.hasOwnProperty("__progressRatio")) {
              photon.__progressRatio = singleHop ? 0 : (idx + particleOffset) / cyclePhotons.length;
            }
            photon.__progressRatio += particleSpeed;
            if (photon.__progressRatio >= 1) {
              if (!singleHop) {
                photon.__progressRatio = photon.__progressRatio % 1;
              } else {
                photon.parent.remove(photon);
                emptyObject(photon);
                return;
              }
            }
            var photonPosRatio = photon.__progressRatio;
            var pos2 = getPhotonPos(photonPosRatio);
            photon.geometry.type !== "SphereGeometry" && photon.lookAt(pos2.x, pos2.y, pos2.z);
            ["x", "y", "z"].forEach(function(dim) {
              return photon.position[dim] = pos2[dim];
            });
          });
        });
      }
    },
    emitParticle: function emitParticle(state, link) {
      if (link && state.graphData.links.includes(link)) {
        if (!link.__singleHopPhotonsObj) {
          var obj = new three$1.Group();
          obj.__linkThreeObjType = "singleHopPhotons";
          link.__singleHopPhotonsObj = obj;
          state.graphScene.add(obj);
        }
        var particleObj = index3(state.linkDirectionalParticleThreeObject)(link);
        if (particleObj && state.linkDirectionalParticleThreeObject === particleObj) {
          particleObj = particleObj.clone();
        }
        if (!particleObj) {
          var particleWidthAccessor = index3(state.linkDirectionalParticleWidth);
          var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;
          var numSegments = state.linkDirectionalParticleResolution;
          var particleGeometry = new three$1.SphereGeometry(photonR, numSegments, numSegments);
          var linkColorAccessor = index3(state.linkColor);
          var particleColorAccessor = index3(state.linkDirectionalParticleColor);
          var photonColor = particleColorAccessor(link) || linkColorAccessor(link) || "#f0f0f0";
          var materialColor = new three$1.Color(colorStr2Hex(photonColor));
          var opacity = state.linkOpacity * 3;
          var particleMaterial = new three$1.MeshLambertMaterial({
            color: materialColor,
            transparent: true,
            opacity
          });
          particleObj = new three$1.Mesh(particleGeometry, particleMaterial);
        }
        link.__singleHopPhotonsObj.add(particleObj);
      }
      return this;
    },
    getGraphBbox: function getGraphBbox(state) {
      var nodeFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return true;
      };
      if (!state.initialised) return null;
      var bboxes = function getBboxes(obj) {
        var bboxes2 = [];
        if (obj.geometry) {
          obj.geometry.computeBoundingBox();
          var box = new three$1.Box3();
          box.copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);
          bboxes2.push(box);
        }
        return bboxes2.concat.apply(bboxes2, _toConsumableArray((obj.children || []).filter(
          function(obj2) {
            return !obj2.hasOwnProperty("__graphObjType") || obj2.__graphObjType === "node" && nodeFilter(obj2.__data);
          }
          // exclude filtered out nodes
        ).map(getBboxes)));
      }(state.graphScene);
      if (!bboxes.length) return null;
      return Object.assign.apply(Object, _toConsumableArray(["x", "y", "z"].map(function(c2) {
        return _defineProperty({}, c2, [min(bboxes, function(bb) {
          return bb.min[c2];
        }), max(bboxes, function(bb) {
          return bb.max[c2];
        })]);
      })));
    }
  },
  stateInit: function stateInit() {
    return {
      d3ForceLayout: simulation_default().force("link", link_default()).force("charge", manyBody_default()).force("center", center_default()).force("dagRadial", null).stop(),
      engineRunning: false
    };
  },
  init: function init(threeObj, state) {
    state.graphScene = threeObj;
    state.nodeDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObj"
    });
    state.linkDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__lineObj"
    });
    state.arrowDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__arrowObj"
    });
    state.particlesDataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__photonsObj"
    });
  },
  update: function update(state, changedProps) {
    var hasAnyPropChanged = function hasAnyPropChanged2(propList) {
      return propList.some(function(p) {
        return changedProps.hasOwnProperty(p);
      });
    };
    state.engineRunning = false;
    typeof state.onUpdate === "function" && state.onUpdate();
    if (state.nodeAutoColorBy !== null && hasAnyPropChanged(["nodeAutoColorBy", "graphData", "nodeColor"])) {
      autoColorObjects(state.graphData.nodes, index3(state.nodeAutoColorBy), state.nodeColor);
    }
    if (state.linkAutoColorBy !== null && hasAnyPropChanged(["linkAutoColorBy", "graphData", "linkColor"])) {
      autoColorObjects(state.graphData.links, index3(state.linkAutoColorBy), state.linkColor);
    }
    if (state._flushObjects || hasAnyPropChanged(["graphData", "nodeThreeObject", "nodeThreeObjectExtend", "nodeVal", "nodeColor", "nodeVisibility", "nodeRelSize", "nodeResolution", "nodeOpacity"])) {
      var customObjectAccessor = index3(state.nodeThreeObject);
      var customObjectExtendAccessor = index3(state.nodeThreeObjectExtend);
      var valAccessor = index3(state.nodeVal);
      var colorAccessor = index3(state.nodeColor);
      var visibilityAccessor = index3(state.nodeVisibility);
      var sphereGeometries = {};
      var sphereMaterials = {};
      if (state._flushObjects || hasAnyPropChanged([
        // recreate objects if any of these props have changed
        "nodeThreeObject",
        "nodeThreeObjectExtend"
      ])) state.nodeDataMapper.clear();
      state.nodeDataMapper.onCreateObj(function(node) {
        var customObj = customObjectAccessor(node);
        var extendObj = customObjectExtendAccessor(node);
        if (customObj && state.nodeThreeObject === customObj) {
          customObj = customObj.clone();
        }
        var obj;
        if (customObj && !extendObj) {
          obj = customObj;
        } else {
          obj = new three$1.Mesh();
          obj.__graphDefaultObj = true;
          if (customObj && extendObj) {
            obj.add(customObj);
          }
        }
        obj.__graphObjType = "node";
        return obj;
      }).onUpdateObj(function(obj, node) {
        if (obj.__graphDefaultObj) {
          var val = valAccessor(node) || 1;
          var radius = Math.cbrt(val) * state.nodeRelSize;
          var numSegments = state.nodeResolution;
          if (!obj.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || obj.geometry.parameters.radius !== radius || obj.geometry.parameters.widthSegments !== numSegments) {
            if (!sphereGeometries.hasOwnProperty(val)) {
              sphereGeometries[val] = new three$1.SphereGeometry(radius, numSegments, numSegments);
            }
            obj.geometry.dispose();
            obj.geometry = sphereGeometries[val];
          }
          var color = colorAccessor(node);
          var materialColor = new three$1.Color(colorStr2Hex(color || "#ffffaa"));
          var opacity = state.nodeOpacity * colorAlpha(color);
          if (obj.material.type !== "MeshLambertMaterial" || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {
            if (!sphereMaterials.hasOwnProperty(color)) {
              sphereMaterials[color] = new three$1.MeshLambertMaterial({
                color: materialColor,
                transparent: true,
                opacity
              });
            }
            obj.material.dispose();
            obj.material = sphereMaterials[color];
          }
        }
      }).digest(state.graphData.nodes.filter(visibilityAccessor));
    }
    if (state._flushObjects || hasAnyPropChanged(["graphData", "linkThreeObject", "linkThreeObjectExtend", "linkMaterial", "linkColor", "linkWidth", "linkVisibility", "linkResolution", "linkOpacity", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "linkDirectionalParticleThreeObject"])) {
      var _customObjectAccessor = index3(state.linkThreeObject);
      var _customObjectExtendAccessor = index3(state.linkThreeObjectExtend);
      var customMaterialAccessor = index3(state.linkMaterial);
      var _visibilityAccessor = index3(state.linkVisibility);
      var _colorAccessor = index3(state.linkColor);
      var widthAccessor = index3(state.linkWidth);
      var cylinderGeometries = {};
      var lambertLineMaterials = {};
      var basicLineMaterials = {};
      var visibleLinks = state.graphData.links.filter(_visibilityAccessor);
      if (state._flushObjects || hasAnyPropChanged([
        // recreate objects if any of these props have changed
        "linkThreeObject",
        "linkThreeObjectExtend",
        "linkWidth"
      ])) state.linkDataMapper.clear();
      state.linkDataMapper.onRemoveObj(function(obj) {
        var singlePhotonsObj = obj.__data && obj.__data.__singleHopPhotonsObj;
        if (singlePhotonsObj) {
          singlePhotonsObj.parent.remove(singlePhotonsObj);
          emptyObject(singlePhotonsObj);
          delete obj.__data.__singleHopPhotonsObj;
        }
      }).onCreateObj(function(link) {
        var customObj = _customObjectAccessor(link);
        var extendObj = _customObjectExtendAccessor(link);
        if (customObj && state.linkThreeObject === customObj) {
          customObj = customObj.clone();
        }
        var defaultObj;
        if (!customObj || extendObj) {
          var useCylinder = !!widthAccessor(link);
          if (useCylinder) {
            defaultObj = new three$1.Mesh();
          } else {
            var lineGeometry = new three$1.BufferGeometry();
            lineGeometry[setAttributeFn]("position", new three$1.BufferAttribute(new Float32Array(2 * 3), 3));
            defaultObj = new three$1.Line(lineGeometry);
          }
        }
        var obj;
        if (!customObj) {
          obj = defaultObj;
          obj.__graphDefaultObj = true;
        } else {
          if (!extendObj) {
            obj = customObj;
          } else {
            obj = new three$1.Group();
            obj.__graphDefaultObj = true;
            obj.add(defaultObj);
            obj.add(customObj);
          }
        }
        obj.renderOrder = 10;
        obj.__graphObjType = "link";
        return obj;
      }).onUpdateObj(function(updObj, link) {
        if (updObj.__graphDefaultObj) {
          var obj = updObj.children.length ? updObj.children[0] : updObj;
          var linkWidth = Math.ceil(widthAccessor(link) * 10) / 10;
          var useCylinder = !!linkWidth;
          if (useCylinder) {
            var r = linkWidth / 2;
            var numSegments = state.linkResolution;
            if (!obj.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || obj.geometry.parameters.radiusTop !== r || obj.geometry.parameters.radialSegments !== numSegments) {
              if (!cylinderGeometries.hasOwnProperty(linkWidth)) {
                var geometry = new three$1.CylinderGeometry(r, r, 1, numSegments, 1, false);
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));
                geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));
                cylinderGeometries[linkWidth] = geometry;
              }
              obj.geometry.dispose();
              obj.geometry = cylinderGeometries[linkWidth];
            }
          }
          var customMaterial = customMaterialAccessor(link);
          if (customMaterial) {
            obj.material = customMaterial;
          } else {
            var color = _colorAccessor(link);
            var materialColor = new three$1.Color(colorStr2Hex(color || "#f0f0f0"));
            var opacity = state.linkOpacity * colorAlpha(color);
            var materialType = useCylinder ? "MeshLambertMaterial" : "LineBasicMaterial";
            if (obj.material.type !== materialType || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {
              var lineMaterials = useCylinder ? lambertLineMaterials : basicLineMaterials;
              if (!lineMaterials.hasOwnProperty(color)) {
                lineMaterials[color] = new three$1[materialType]({
                  color: materialColor,
                  transparent: opacity < 1,
                  opacity,
                  depthWrite: opacity >= 1
                  // Prevent transparency issues
                });
              }
              obj.material.dispose();
              obj.material = lineMaterials[color];
            }
          }
        }
      }).digest(visibleLinks);
      if (state.linkDirectionalArrowLength || changedProps.hasOwnProperty("linkDirectionalArrowLength")) {
        var arrowLengthAccessor = index3(state.linkDirectionalArrowLength);
        var arrowColorAccessor = index3(state.linkDirectionalArrowColor);
        state.arrowDataMapper.onCreateObj(function() {
          var obj = new three$1.Mesh(void 0, new three$1.MeshLambertMaterial({
            transparent: true
          }));
          obj.__linkThreeObjType = "arrow";
          return obj;
        }).onUpdateObj(function(obj, link) {
          var arrowLength = arrowLengthAccessor(link);
          var numSegments = state.linkDirectionalArrowResolution;
          if (!obj.geometry.type.match(/^Cone(Buffer)?Geometry$/) || obj.geometry.parameters.height !== arrowLength || obj.geometry.parameters.radialSegments !== numSegments) {
            var coneGeometry = new three$1.ConeGeometry(arrowLength * 0.25, arrowLength, numSegments);
            coneGeometry.translate(0, arrowLength / 2, 0);
            coneGeometry.rotateX(Math.PI / 2);
            obj.geometry.dispose();
            obj.geometry = coneGeometry;
          }
          var arrowColor = arrowColorAccessor(link) || _colorAccessor(link) || "#f0f0f0";
          obj.material.color = new three$1.Color(colorStr2Hex(arrowColor));
          obj.material.opacity = state.linkOpacity * 3 * colorAlpha(arrowColor);
        }).digest(visibleLinks.filter(arrowLengthAccessor));
      }
      if (state.linkDirectionalParticles || changedProps.hasOwnProperty("linkDirectionalParticles")) {
        var particlesAccessor = index3(state.linkDirectionalParticles);
        var particleWidthAccessor = index3(state.linkDirectionalParticleWidth);
        var particleColorAccessor = index3(state.linkDirectionalParticleColor);
        var particleObjectAccessor = index3(state.linkDirectionalParticleThreeObject);
        var particleMaterials = {};
        var particleGeometries = {};
        state.particlesDataMapper.onCreateObj(function() {
          var obj = new three$1.Group();
          obj.__linkThreeObjType = "photons";
          obj.__photonDataMapper = new ThreeDigest(obj);
          return obj;
        }).onUpdateObj(function(obj, link) {
          var curPhoton = !!obj.children.length && obj.children[0];
          var customObj = particleObjectAccessor(link);
          var particleGeometry, particleMaterial;
          if (customObj) {
            particleGeometry = customObj.geometry;
            particleMaterial = customObj.material;
          } else {
            var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;
            var numSegments = state.linkDirectionalParticleResolution;
            if (curPhoton && curPhoton.geometry.parameters.radius === photonR && curPhoton.geometry.parameters.widthSegments === numSegments) {
              particleGeometry = curPhoton.geometry;
            } else {
              if (!particleGeometries.hasOwnProperty(photonR)) {
                particleGeometries[photonR] = new three$1.SphereGeometry(photonR, numSegments, numSegments);
              }
              particleGeometry = particleGeometries[photonR];
            }
            var photonColor = particleColorAccessor(link) || _colorAccessor(link) || "#f0f0f0";
            var materialColor = new three$1.Color(colorStr2Hex(photonColor));
            var opacity = state.linkOpacity * 3;
            if (curPhoton && curPhoton.material.color.equals(materialColor) && curPhoton.material.opacity === opacity) {
              particleMaterial = curPhoton.material;
            } else {
              if (!particleMaterials.hasOwnProperty(photonColor)) {
                particleMaterials[photonColor] = new three$1.MeshLambertMaterial({
                  color: materialColor,
                  transparent: true,
                  opacity
                });
              }
              particleMaterial = particleMaterials[photonColor];
            }
          }
          if (curPhoton) {
            curPhoton.geometry !== particleGeometry && curPhoton.geometry.dispose();
            curPhoton.material !== particleMaterial && curPhoton.material.dispose();
          }
          var numPhotons = Math.round(Math.abs(particlesAccessor(link)));
          obj.__photonDataMapper.id(function(d) {
            return d.idx;
          }).onCreateObj(function() {
            return new three$1.Mesh(particleGeometry, particleMaterial);
          }).onUpdateObj(function(obj2) {
            obj2.geometry = particleGeometry;
            obj2.material = particleMaterial;
          }).digest(_toConsumableArray(new Array(numPhotons)).map(function(_, idx) {
            return {
              idx
            };
          }));
        }).digest(visibleLinks.filter(particlesAccessor));
      }
    }
    state._flushObjects = false;
    if (hasAnyPropChanged(["graphData", "nodeId", "linkSource", "linkTarget", "numDimensions", "forceEngine", "dagMode", "dagNodeFilter", "dagLevelDistance"])) {
      state.engineRunning = false;
      state.graphData.links.forEach(function(link) {
        link.source = link[state.linkSource];
        link.target = link[state.linkTarget];
      });
      var isD3Sim = state.forceEngine !== "ngraph";
      var layout;
      if (isD3Sim) {
        (layout = state.d3ForceLayout).stop().alpha(1).numDimensions(state.numDimensions).nodes(state.graphData.nodes);
        var linkForce = state.d3ForceLayout.force("link");
        if (linkForce) {
          linkForce.id(function(d) {
            return d[state.nodeId];
          }).links(state.graphData.links);
        }
        var nodeDepths = state.dagMode && getDagDepths(state.graphData, function(node) {
          return node[state.nodeId];
        }, {
          nodeFilter: state.dagNodeFilter,
          onLoopError: state.onDagError || void 0
        });
        var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));
        var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? 0.7 : 1);
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(changedProps.dagMode)) {
          var resetProp = ["lr", "rl"].includes(changedProps.dagMode) ? "fx" : ["td", "bu"].includes(changedProps.dagMode) ? "fy" : "fz";
          state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
            return delete node[resetProp];
          });
        }
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(state.dagMode)) {
          var invert = ["rl", "td", "zout"].includes(state.dagMode);
          var fixFn = function fixFn2(node) {
            return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);
          };
          var _resetProp = ["lr", "rl"].includes(state.dagMode) ? "fx" : ["td", "bu"].includes(state.dagMode) ? "fy" : "fz";
          state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
            return node[_resetProp] = fixFn(node);
          });
        }
        state.d3ForceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? radial_default(function(node) {
          var nodeDepth = nodeDepths[node[state.nodeId]] || -1;
          return (state.dagMode === "radialin" ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
        }).strength(function(node) {
          return state.dagNodeFilter(node) ? 1 : 0;
        }) : null);
      } else {
        var _graph = ngraph.graph();
        state.graphData.nodes.forEach(function(node) {
          _graph.addNode(node[state.nodeId]);
        });
        state.graphData.links.forEach(function(link) {
          _graph.addLink(link.source, link.target);
        });
        layout = ngraph.forcelayout(_graph, _objectSpread2({
          dimensions: state.numDimensions
        }, state.ngraphPhysics));
        layout.graph = _graph;
      }
      for (var i = 0; i < state.warmupTicks && !(isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin); i++) {
        layout[isD3Sim ? "tick" : "step"]();
      }
      state.layout = layout;
      this.resetCountdown();
    }
    state.engineRunning = true;
    state.onFinishUpdate();
  }
});
function fromKapsule(kapsule) {
  var baseClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object;
  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var ForceGraph2 = function(_baseClass) {
    function ForceGraph3() {
      var _this;
      _classCallCheck(this, ForceGraph3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, ForceGraph3, [].concat(args));
      _this.__kapsuleInstance = _construct(kapsule, [].concat(_toConsumableArray(initKapsuleWithSelf ? [_this] : []), args));
      return _this;
    }
    _inherits(ForceGraph3, _baseClass);
    return _createClass(ForceGraph3);
  }(baseClass);
  Object.keys(kapsule()).forEach(function(m2) {
    return ForceGraph2.prototype[m2] = function() {
      var _this$__kapsuleInstan;
      var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m2].apply(_this$__kapsuleInstan, arguments);
      return returnVal === this.__kapsuleInstance ? this : returnVal;
    };
  });
  return ForceGraph2;
}
var three = window.THREE ? window.THREE : {
  Group
};
var threeForcegraph = fromKapsule(ForceGraph, three.Group, true);

// node_modules/3d-force-graph/dist/3d-force-graph.mjs
function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z = ".graph-info-msg {\n  top: 50%;\n  width: 100%;\n  text-align: center;\n  color: lavender;\n  opacity: 0.7;\n  font-size: 22px;\n  position: absolute;\n  font-family: Sans-serif;\n}\n\n.scene-container .clickable {\n  cursor: pointer;\n}\n\n.scene-container .grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.scene-container .grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}";
styleInject(css_248z);
function _arrayLikeToArray2(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function _arrayWithoutHoles2(r) {
  if (Array.isArray(r)) return _arrayLikeToArray2(r);
}
function _defineProperty2(e, r, t) {
  return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _iterableToArray2(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread22(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _toConsumableArray2(r) {
  return _arrayWithoutHoles2(r) || _iterableToArray2(r) || _unsupportedIterableToArray2(r) || _nonIterableSpread2();
}
function _toPrimitive2(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey2(t) {
  var i = _toPrimitive2(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray2(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray2(r, a2);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a2) : void 0;
  }
}
function linkKapsule(kapsulePropName, kapsuleType) {
  var dummyK = new kapsuleType();
  dummyK._destructor && dummyK._destructor();
  return {
    linkProp: function linkProp(prop) {
      return {
        "default": dummyK[prop](),
        onChange: function onChange10(v, state) {
          state[kapsulePropName][prop](v);
        },
        triggerUpdate: false
      };
    },
    linkMethod: function linkMethod(method) {
      return function(state) {
        var kapsuleInstance = state[kapsulePropName];
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
        return returnVal === kapsuleInstance ? this : returnVal;
      };
    }
  };
}
var three2 = window.THREE ? window.THREE : {
  AmbientLight,
  DirectionalLight,
  REVISION
};
var CAMERA_DISTANCE2NODES_FACTOR = 170;
var bindFG = linkKapsule("forceGraph", threeForcegraph);
var linkedFGProps = Object.assign.apply(Object, _toConsumableArray2(["jsonUrl", "graphData", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeVisibility", "nodeThreeObject", "nodeThreeObjectExtend", "nodePositionUpdate", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleOffset", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "linkDirectionalParticleThreeObject", "forceEngine", "d3AlphaDecay", "d3VelocityDecay", "d3AlphaMin", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(p) {
  return _defineProperty2({}, p, bindFG.linkProp(p));
})));
var linkedFGMethods = Object.assign.apply(Object, _toConsumableArray2(["refresh", "getGraphBbox", "d3Force", "d3ReheatSimulation", "emitParticle"].map(function(p) {
  return _defineProperty2({}, p, bindFG.linkMethod(p));
})));
var bindRenderObjs = linkKapsule("renderObjs", threeRenderObjects);
var linkedRenderObjsProps = Object.assign.apply(Object, _toConsumableArray2(["width", "height", "backgroundColor", "showNavInfo", "enablePointerInteraction"].map(function(p) {
  return _defineProperty2({}, p, bindRenderObjs.linkProp(p));
})));
var linkedRenderObjsMethods = Object.assign.apply(Object, _toConsumableArray2(["lights", "cameraPosition", "postProcessingComposer"].map(function(p) {
  return _defineProperty2({}, p, bindRenderObjs.linkMethod(p));
})).concat([{
  graph2ScreenCoords: bindRenderObjs.linkMethod("getScreenCoords"),
  screen2GraphCoords: bindRenderObjs.linkMethod("getSceneCoords")
}]));
var _3dForceGraph = index2({
  props: _objectSpread22(_objectSpread22({
    nodeLabel: {
      "default": "name",
      triggerUpdate: false
    },
    linkLabel: {
      "default": "name",
      triggerUpdate: false
    },
    linkHoverPrecision: {
      "default": 1,
      onChange: function onChange8(p, state) {
        return state.renderObjs.lineHoverPrecision(p);
      },
      triggerUpdate: false
    },
    enableNavigationControls: {
      "default": true,
      onChange: function onChange9(enable, state) {
        var controls2 = state.renderObjs.controls();
        if (controls2) {
          controls2.enabled = enable;
          enable && controls2.domElement && controls2.domElement.dispatchEvent(new PointerEvent("pointerup"));
        }
      },
      triggerUpdate: false
    },
    enableNodeDrag: {
      "default": true,
      triggerUpdate: false
    },
    onNodeDrag: {
      "default": function _default8() {
      },
      triggerUpdate: false
    },
    onNodeDragEnd: {
      "default": function _default9() {
      },
      triggerUpdate: false
    },
    onNodeClick: {
      triggerUpdate: false
    },
    onNodeRightClick: {
      triggerUpdate: false
    },
    onNodeHover: {
      triggerUpdate: false
    },
    onLinkClick: {
      triggerUpdate: false
    },
    onLinkRightClick: {
      triggerUpdate: false
    },
    onLinkHover: {
      triggerUpdate: false
    },
    onBackgroundClick: {
      triggerUpdate: false
    },
    onBackgroundRightClick: {
      triggerUpdate: false
    },
    showPointerCursor: {
      "default": true,
      triggerUpdate: false
    }
  }, linkedFGProps), linkedRenderObjsProps),
  methods: _objectSpread22(_objectSpread22({
    zoomToFit: function zoomToFit(state, transitionDuration, padding) {
      var _state$forceGraph;
      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        bboxArgs[_key - 3] = arguments[_key];
      }
      state.renderObjs.fitToBbox((_state$forceGraph = state.forceGraph).getGraphBbox.apply(_state$forceGraph, bboxArgs), transitionDuration, padding);
      return this;
    },
    pauseAnimation: function pauseAnimation(state) {
      if (state.animationFrameRequestId !== null) {
        cancelAnimationFrame(state.animationFrameRequestId);
        state.animationFrameRequestId = null;
      }
      return this;
    },
    resumeAnimation: function resumeAnimation(state) {
      if (state.animationFrameRequestId === null) {
        this._animationCycle();
      }
      return this;
    },
    _animationCycle: function _animationCycle(state) {
      if (state.enablePointerInteraction) {
        this.renderer().domElement.style.cursor = null;
      }
      state.forceGraph.tickFrame();
      state.renderObjs.tick();
      state.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
    },
    scene: function scene(state) {
      return state.renderObjs.scene();
    },
    // Expose scene
    camera: function camera(state) {
      return state.renderObjs.camera();
    },
    // Expose camera
    renderer: function renderer(state) {
      return state.renderObjs.renderer();
    },
    // Expose renderer
    controls: function controls(state) {
      return state.renderObjs.controls();
    },
    // Expose controls
    tbControls: function tbControls(state) {
      return state.renderObjs.tbControls();
    },
    // To be deprecated
    _destructor: function _destructor() {
      this.pauseAnimation();
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }, linkedFGMethods), linkedRenderObjsMethods),
  stateInit: function stateInit2(_ref5) {
    var controlType = _ref5.controlType, rendererConfig = _ref5.rendererConfig, extraRenderers = _ref5.extraRenderers;
    var forceGraph = new threeForcegraph();
    return {
      forceGraph,
      renderObjs: threeRenderObjects({
        controlType,
        rendererConfig,
        extraRenderers
      }).objects([forceGraph]).lights([new three2.AmbientLight(13421772, Math.PI), new three2.DirectionalLight(16777215, 0.6 * Math.PI)])
    };
  },
  init: function init2(domNode, state) {
    domNode.innerHTML = "";
    domNode.appendChild(state.container = document.createElement("div"));
    state.container.style.position = "relative";
    var roDomNode = document.createElement("div");
    state.container.appendChild(roDomNode);
    state.renderObjs(roDomNode);
    var camera2 = state.renderObjs.camera();
    var renderer2 = state.renderObjs.renderer();
    var controls2 = state.renderObjs.controls();
    controls2.enabled = !!state.enableNavigationControls;
    state.lastSetCameraZ = camera2.position.z;
    var infoElem;
    state.container.appendChild(infoElem = document.createElement("div"));
    infoElem.className = "graph-info-msg";
    infoElem.textContent = "";
    state.forceGraph.onLoading(function() {
      infoElem.textContent = "Loading...";
    }).onFinishLoading(function() {
      infoElem.textContent = "";
    }).onUpdate(function() {
      state.graphData = state.forceGraph.graphData();
      if (camera2.position.x === 0 && camera2.position.y === 0 && camera2.position.z === state.lastSetCameraZ && state.graphData.nodes.length) {
        camera2.lookAt(state.forceGraph.position);
        state.lastSetCameraZ = camera2.position.z = Math.cbrt(state.graphData.nodes.length) * CAMERA_DISTANCE2NODES_FACTOR;
      }
    }).onFinishUpdate(function() {
      if (state._dragControls) {
        var curNodeDrag = state.graphData.nodes.find(function(node) {
          return node.__initialFixedPos && !node.__disposeControlsAfterDrag;
        });
        if (curNodeDrag) {
          curNodeDrag.__disposeControlsAfterDrag = true;
        } else {
          state._dragControls.dispose();
        }
        state._dragControls = void 0;
      }
      if (state.enableNodeDrag && state.enablePointerInteraction && state.forceEngine === "d3") {
        var dragControls = state._dragControls = new DragControls(state.graphData.nodes.map(function(node) {
          return node.__threeObj;
        }).filter(function(obj) {
          return obj;
        }), camera2, renderer2.domElement);
        dragControls.addEventListener("dragstart", function(event) {
          var nodeObj = getGraphObj(event.object);
          if (!nodeObj) return;
          controls2.enabled = false;
          event.object.__initialPos = event.object.position.clone();
          event.object.__prevPos = event.object.position.clone();
          var node = nodeObj.__data;
          !node.__initialFixedPos && (node.__initialFixedPos = {
            fx: node.fx,
            fy: node.fy,
            fz: node.fz
          });
          !node.__initialPos && (node.__initialPos = {
            x: node.x,
            y: node.y,
            z: node.z
          });
          ["x", "y", "z"].forEach(function(c2) {
            return node["f".concat(c2)] = node[c2];
          });
          renderer2.domElement.classList.add("grabbable");
        });
        dragControls.addEventListener("drag", function(event) {
          var nodeObj = getGraphObj(event.object);
          if (!nodeObj) return;
          if (!event.object.hasOwnProperty("__graphObjType")) {
            var initPos = event.object.__initialPos;
            var prevPos = event.object.__prevPos;
            var _newPos = event.object.position;
            nodeObj.position.add(_newPos.clone().sub(prevPos));
            prevPos.copy(_newPos);
            _newPos.copy(initPos);
          }
          var node = nodeObj.__data;
          var newPos = nodeObj.position;
          var translate = {
            x: newPos.x - node.x,
            y: newPos.y - node.y,
            z: newPos.z - node.z
          };
          ["x", "y", "z"].forEach(function(c2) {
            return node["f".concat(c2)] = node[c2] = newPos[c2];
          });
          state.forceGraph.d3AlphaTarget(0.3).resetCountdown();
          node.__dragged = true;
          state.onNodeDrag(node, translate);
        });
        dragControls.addEventListener("dragend", function(event) {
          var nodeObj = getGraphObj(event.object);
          if (!nodeObj) return;
          delete event.object.__initialPos;
          delete event.object.__prevPos;
          var node = nodeObj.__data;
          if (node.__disposeControlsAfterDrag) {
            dragControls.dispose();
            delete node.__disposeControlsAfterDrag;
          }
          var initFixedPos = node.__initialFixedPos;
          var initPos = node.__initialPos;
          var translate = {
            x: initPos.x - node.x,
            y: initPos.y - node.y,
            z: initPos.z - node.z
          };
          if (initFixedPos) {
            ["x", "y", "z"].forEach(function(c2) {
              var fc = "f".concat(c2);
              if (initFixedPos[fc] === void 0) {
                delete node[fc];
              }
            });
            delete node.__initialFixedPos;
            delete node.__initialPos;
            if (node.__dragged) {
              delete node.__dragged;
              state.onNodeDragEnd(node, translate);
            }
          }
          state.forceGraph.d3AlphaTarget(0).resetCountdown();
          if (state.enableNavigationControls) {
            var _controls$_onPointerC;
            controls2.enabled = true;
            controls2._status && ((_controls$_onPointerC = controls2._onPointerCancel) === null || _controls$_onPointerC === void 0 ? void 0 : _controls$_onPointerC.call(controls2));
            controls2.domElement && controls2.domElement.ownerDocument && controls2.domElement.ownerDocument.dispatchEvent(
              // simulate mouseup to ensure the controls don't take over after dragend
              new PointerEvent("pointerup", {
                pointerType: "touch"
              })
            );
          }
          renderer2.domElement.classList.remove("grabbable");
        });
      }
    });
    three2.REVISION < 155 && (state.renderObjs.renderer().useLegacyLights = false);
    state.renderObjs.hoverOrderComparator(function(a2, b) {
      var aObj = getGraphObj(a2);
      if (!aObj) return 1;
      var bObj = getGraphObj(b);
      if (!bObj) return -1;
      var isNode = function isNode2(o) {
        return o.__graphObjType === "node";
      };
      return isNode(bObj) - isNode(aObj);
    }).tooltipContent(function(obj) {
      var graphObj = getGraphObj(obj);
      return graphObj ? index3(state["".concat(graphObj.__graphObjType, "Label")])(graphObj.__data) || "" : "";
    }).hoverDuringDrag(false).onHover(function(obj) {
      var hoverObj = getGraphObj(obj);
      if (hoverObj !== state.hoverObj) {
        var prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;
        var prevObjData = state.hoverObj ? state.hoverObj.__data : null;
        var objType = hoverObj ? hoverObj.__graphObjType : null;
        var objData = hoverObj ? hoverObj.__data : null;
        if (prevObjType && prevObjType !== objType) {
          var fn = state["on".concat(prevObjType === "node" ? "Node" : "Link", "Hover")];
          fn && fn(null, prevObjData);
        }
        if (objType) {
          var _fn = state["on".concat(objType === "node" ? "Node" : "Link", "Hover")];
          _fn && _fn(objData, prevObjType === objType ? prevObjData : null);
        }
        renderer2.domElement.classList[(hoverObj && state["on".concat(objType === "node" ? "Node" : "Link", "Click")] || !hoverObj && state.onBackgroundClick) && index3(state.showPointerCursor)(objData) ? "add" : "remove"]("clickable");
        state.hoverObj = hoverObj;
      }
    }).clickAfterDrag(false).onClick(function(obj, ev) {
      var graphObj = getGraphObj(obj);
      if (graphObj) {
        var fn = state["on".concat(graphObj.__graphObjType === "node" ? "Node" : "Link", "Click")];
        fn && fn(graphObj.__data, ev);
      } else {
        state.onBackgroundClick && state.onBackgroundClick(ev);
      }
    }).onRightClick(function(obj, ev) {
      var graphObj = getGraphObj(obj);
      if (graphObj) {
        var fn = state["on".concat(graphObj.__graphObjType === "node" ? "Node" : "Link", "RightClick")];
        fn && fn(graphObj.__data, ev);
      } else {
        state.onBackgroundRightClick && state.onBackgroundRightClick(ev);
      }
    });
    this._animationCycle();
  }
});
function getGraphObj(object) {
  var obj = object;
  while (obj && !obj.hasOwnProperty("__graphObjType")) {
    obj = obj.parent;
  }
  return obj;
}

// node_modules/react-force-graph-3d/dist/react-force-graph-3d.mjs
var import_prop_types = __toESM(require_prop_types(), 1);
var commonPropTypes = {
  width: import_prop_types.default.number,
  height: import_prop_types.default.number,
  graphData: import_prop_types.default.shape({
    nodes: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired,
    links: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired
  }),
  backgroundColor: import_prop_types.default.string,
  nodeRelSize: import_prop_types.default.number,
  nodeId: import_prop_types.default.string,
  nodeLabel: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  nodeVal: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  nodeVisibility: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  nodeColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  nodeAutoColorBy: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  onNodeHover: import_prop_types.default.func,
  onNodeClick: import_prop_types.default.func,
  linkSource: import_prop_types.default.string,
  linkTarget: import_prop_types.default.string,
  linkLabel: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkVisibility: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  linkColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkAutoColorBy: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkWidth: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkCurvature: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalArrowLength: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalArrowColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalArrowRelPos: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticles: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleSpeed: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleOffset: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleWidth: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkDirectionalParticleColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  onLinkHover: import_prop_types.default.func,
  onLinkClick: import_prop_types.default.func,
  dagMode: import_prop_types.default.oneOf(["td", "bu", "lr", "rl", "zin", "zout", "radialin", "radialout"]),
  dagLevelDistance: import_prop_types.default.number,
  dagNodeFilter: import_prop_types.default.func,
  onDagError: import_prop_types.default.func,
  d3AlphaMin: import_prop_types.default.number,
  d3AlphaDecay: import_prop_types.default.number,
  d3VelocityDecay: import_prop_types.default.number,
  warmupTicks: import_prop_types.default.number,
  cooldownTicks: import_prop_types.default.number,
  cooldownTime: import_prop_types.default.number,
  onEngineTick: import_prop_types.default.func,
  onEngineStop: import_prop_types.default.func,
  getGraphBbox: import_prop_types.default.func
};
var pointerBasedPropTypes = {
  zoomToFit: import_prop_types.default.func,
  onNodeRightClick: import_prop_types.default.func,
  onNodeDrag: import_prop_types.default.func,
  onNodeDragEnd: import_prop_types.default.func,
  onLinkRightClick: import_prop_types.default.func,
  linkHoverPrecision: import_prop_types.default.number,
  onBackgroundClick: import_prop_types.default.func,
  onBackgroundRightClick: import_prop_types.default.func,
  showPointerCursor: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
  enablePointerInteraction: import_prop_types.default.bool,
  enableNodeDrag: import_prop_types.default.bool
};
var threeBasedPropTypes = {
  showNavInfo: import_prop_types.default.bool,
  nodeOpacity: import_prop_types.default.number,
  nodeResolution: import_prop_types.default.number,
  nodeThreeObject: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  nodeThreeObjectExtend: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  nodePositionUpdate: import_prop_types.default.func,
  linkOpacity: import_prop_types.default.number,
  linkResolution: import_prop_types.default.number,
  linkCurveRotation: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.func]),
  linkMaterial: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  linkThreeObject: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  linkThreeObjectExtend: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.func]),
  linkPositionUpdate: import_prop_types.default.func,
  linkDirectionalArrowResolution: import_prop_types.default.number,
  linkDirectionalParticleResolution: import_prop_types.default.number,
  linkDirectionalParticleThreeObject: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string, import_prop_types.default.func]),
  forceEngine: import_prop_types.default.oneOf(["d3", "ngraph"]),
  ngraphPhysics: import_prop_types.default.object,
  numDimensions: import_prop_types.default.oneOf([1, 2, 3])
};
Object.assign({}, commonPropTypes, pointerBasedPropTypes, {
  linkLineDash: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.number), import_prop_types.default.string, import_prop_types.default.func]),
  nodeCanvasObjectMode: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  nodeCanvasObject: import_prop_types.default.func,
  nodePointerAreaPaint: import_prop_types.default.func,
  linkCanvasObjectMode: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkCanvasObject: import_prop_types.default.func,
  linkPointerAreaPaint: import_prop_types.default.func,
  linkDirectionalParticleCanvasObject: import_prop_types.default.func,
  autoPauseRedraw: import_prop_types.default.bool,
  minZoom: import_prop_types.default.number,
  maxZoom: import_prop_types.default.number,
  enableZoomInteraction: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
  enablePanInteraction: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
  onZoom: import_prop_types.default.func,
  onZoomEnd: import_prop_types.default.func,
  onRenderFramePre: import_prop_types.default.func,
  onRenderFramePost: import_prop_types.default.func
});
var ForceGraph3DPropTypes = Object.assign({}, commonPropTypes, pointerBasedPropTypes, threeBasedPropTypes, {
  enableNavigationControls: import_prop_types.default.bool,
  controlType: import_prop_types.default.oneOf(["trackball", "orbit", "fly"]),
  rendererConfig: import_prop_types.default.object,
  extraRenderers: import_prop_types.default.arrayOf(import_prop_types.default.shape({
    render: import_prop_types.default.func.isRequired
  }))
});
Object.assign({}, commonPropTypes, threeBasedPropTypes, {
  nodeDesc: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
  linkDesc: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func])
});
Object.assign({}, commonPropTypes, threeBasedPropTypes, {
  markerAttrs: import_prop_types.default.object,
  yOffset: import_prop_types.default.number,
  glScale: import_prop_types.default.number
});
var ForceGraph3D = index(_3dForceGraph, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "cameraPosition",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords",
    "postProcessingComposer",
    "lights",
    "scene",
    "camera",
    "renderer",
    "controls",
    "refresh"
  ],
  initPropNames: ["controlType", "rendererConfig", "extraRenderers"]
});
ForceGraph3D.displayName = "ForceGraph3D";
ForceGraph3D.propTypes = ForceGraph3DPropTypes;
export {
  ForceGraph3D as default
};
//# sourceMappingURL=react-force-graph-3d.js.map
